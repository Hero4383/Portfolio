<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Container Lab Playground | Tree of Life</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at top, #1f2a36 0%, #141b24 60%, #0c1118 100%);
            color: #ecf0f1;
            overflow: hidden;
        }

        #playgroundCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .hud {
            position: fixed;
            top: 24px;
            left: 24px;
            background: rgba(15, 21, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 1.2rem 1.4rem;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            max-width: 320px;
        }

        .hud h1 {
            font-size: 1.2rem;
            margin-bottom: 0.4rem;
            color: #f5f7fa;
        }

        .hud p {
            font-size: 0.9rem;
            color: rgba(236, 240, 241, 0.75);
            margin-bottom: 0.6rem;
        }

        .badge {
            display: inline-block;
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid rgba(52, 152, 219, 0.4);
            color: #a9d2f4;
            padding: 0.2rem 0.6rem;
            border-radius: 999px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .controls {
            font-size: 0.85rem;
            color: rgba(236, 240, 241, 0.7);
            line-height: 1.5;
        }

        .status {
            margin-top: 0.6rem;
            font-size: 0.85rem;
            color: #9bd5ff;
        }

        .narration {
            margin-top: 0.6rem;
            font-size: 0.82rem;
            color: rgba(236, 240, 241, 0.75);
            background: rgba(15, 21, 30, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            padding: 0.6rem 0.7rem;
            line-height: 1.4;
        }

        .scoreboard {
            margin-top: 0.6rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            font-size: 0.85rem;
            color: rgba(236, 240, 241, 0.8);
        }

        .chain {
            margin-top: 0.7rem;
        }

        .chain-label {
            font-size: 0.7rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(236, 240, 241, 0.55);
            margin-bottom: 0.35rem;
        }

        .chain-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            margin-bottom: 0.45rem;
        }

        .chain-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            opacity: 0.6;
        }

        .chain-dot.active {
            opacity: 1;
            box-shadow: 0 0 8px currentColor;
            transform: scale(1.1);
        }

        .chain-dot.completed {
            opacity: 0.9;
            filter: brightness(1.1);
        }

        .chain-next {
            font-size: 0.82rem;
            color: rgba(236, 240, 241, 0.78);
            margin-bottom: 0.2rem;
        }

        .legend {
            margin-top: 0.8rem;
            display: grid;
            gap: 0.4rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.82rem;
            color: rgba(236, 240, 241, 0.7);
        }

        .legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .legend-swatch.power {
            border-radius: 50%;
        }

        .corner-button {
            position: fixed;
            right: 24px;
            top: 24px;
            background: rgba(15, 21, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #ecf0f1;
            padding: 0.7rem 1.1rem;
            border-radius: 999px;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .corner-button:hover {
            background: rgba(52, 152, 219, 0.25);
        }

        .banner {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 21, 30, 0.75);
            border: 1px solid rgba(46, 204, 113, 0.35);
            color: #b5f5cc;
            padding: 0.6rem 1.4rem;
            border-radius: 999px;
            font-size: 0.9rem;
            display: none;
        }

        .banner.visible {
            display: inline-block;
        }

        .debug-panel {
            position: fixed;
            right: 24px;
            bottom: 24px;
            background: rgba(15, 21, 30, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 0.8rem 1rem;
            font-family: "Consolas", "Courier New", monospace;
            font-size: 0.75rem;
            color: rgba(236, 240, 241, 0.85);
            white-space: pre;
            max-width: 320px;
            z-index: 5;
        }

        .hat-panel {
            position: fixed;
            right: 24px;
            top: 88px;
            background: rgba(15, 21, 30, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 1rem 1.2rem;
            width: 240px;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
        }

        .hat-panel h3 {
            font-size: 0.95rem;
            margin-bottom: 0.6rem;
            color: #f5f7fa;
        }

        .hat-row {
            margin-bottom: 0.6rem;
        }

        .hat-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.78rem;
            color: rgba(236, 240, 241, 0.75);
            margin-bottom: 0.3rem;
        }

        .hat-bar {
            width: 100%;
            height: 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            overflow: hidden;
        }

        .hat-fill {
            height: 100%;
            border-radius: 999px;
        }

        .hat-empty {
            font-size: 0.75rem;
            color: rgba(236, 240, 241, 0.55);
        }

        .tutorial-overlay {
            position: fixed;
            inset: 0;
            background: rgba(9, 12, 18, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .tutorial-overlay.visible {
            display: flex;
        }

        .tutorial-card {
            background: rgba(15, 21, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 1.6rem 1.8rem;
            max-width: 420px;
            width: 90%;
            box-shadow: 0 25px 55px rgba(0, 0, 0, 0.45);
        }

        .tutorial-card h2 {
            font-size: 1.1rem;
            color: #f5f7fa;
            margin-bottom: 0.6rem;
        }

        .tutorial-card p {
            font-size: 0.92rem;
            color: rgba(236, 240, 241, 0.8);
            line-height: 1.5;
            margin-bottom: 1.2rem;
        }

        .tutorial-card button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: none;
            color: #ffffff;
            padding: 0.6rem 1.4rem;
            border-radius: 999px;
            font-weight: 600;
            cursor: pointer;
        }

        .tutorial-card button:hover {
            filter: brightness(1.05);
        }

        .hat-select-overlay {
            position: fixed;
            inset: 0;
            background: rgba(9, 12, 18, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 25;
        }

        .hat-select-overlay.visible {
            display: flex;
        }

        .hat-select-card {
            background: rgba(15, 21, 30, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 1.6rem 1.8rem;
            max-width: 460px;
            width: 92%;
            box-shadow: 0 25px 55px rgba(0, 0, 0, 0.45);
        }

        .hat-select-card h2 {
            font-size: 1.1rem;
            color: #f5f7fa;
            margin-bottom: 0.6rem;
        }

        .hat-select-card p {
            font-size: 0.88rem;
            color: rgba(236, 240, 241, 0.75);
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .hat-options {
            display: grid;
            gap: 0.6rem;
            margin-bottom: 1rem;
        }

        .hat-option {
            display: flex;
            gap: 0.6rem;
            align-items: flex-start;
            font-size: 0.85rem;
            color: rgba(236, 240, 241, 0.75);
        }

        .hat-option input {
            margin-top: 0.2rem;
        }

        .hat-select-card button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: none;
            color: #ffffff;
            padding: 0.6rem 1.4rem;
            border-radius: 999px;
            font-weight: 600;
            cursor: pointer;
        }

        .hat-select-card button:hover {
            filter: brightness(1.05);
        }
    </style>
</head>
<body>
    <canvas id="playgroundCanvas" aria-label="Interactive container lab playground"></canvas>

    <div class="hud">
        <div class="badge" id="containerBadge">Slave Container</div>
        <h1>Autonomous Task Runner</h1>
        <p>Each level represents a sealed container environment. Dots are work units; power nodes unlock specialized actions.</p>
        <div class="controls">
            P: toggle player mode (demo defaults to autopilot)<br>
            Arrow keys (W/S/D optional): move in player mode<br>
            Hold Space: eat dots in player mode<br>
            T: use hat ability<br>
            B: toggle safe mode (debug)<br>
            M: toggle sound<br>
            Esc: pause<br>
            R: reset level<br>
            Hats: Script, Phase, Wrench, Zap (equip on deploy)
        </div>
        <div class="status" id="statusText">Mode: Demo | Autopilot: On</div>
        <div class="narration" id="narrationText">Autoplay demo: collecting task dots in the required order.</div>
        <div class="scoreboard">
            <div>Score: <span id="scoreValue">0</span></div>
            <div>Level: <span id="levelValue">1</span></div>
            <div>Lives: <span id="livesValue">3</span></div>
            <div>Time: <span id="timeValue">0:00</span></div>
        </div>
        <div class="chain">
            <div class="chain-label">Chain Order</div>
            <div class="chain-row" id="chainRow"></div>
            <div class="chain-next">Next: <span id="nextValue">Executing Script</span></div>
            <div class="chain-next">Progress: <span id="chainValue">0/7</span></div>
        </div>
        <div class="legend">
            <div class="legend-item"><span class="legend-swatch" style="background:#e74c3c;"></span>Executing Script</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#f39c12;"></span>Utilizing Tool</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#f1c40f;"></span>Accessing MCP</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#3498db;"></span>Utilizing Skill</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#2ecc71;"></span>Validating Output</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#8e5b3a;"></span>Persisting State</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#2d3436;"></span>Finalizing Run</div>
            <div class="legend-item"><span class="legend-swatch power" style="background:#ff7675;"></span>Power Node (Tool Access)</div>
            <div class="legend-item"><span class="legend-swatch power" style="background:#00cec9;"></span>Script Boost (Speed)</div>
            <div class="legend-item"><span class="legend-swatch" style="background:#ff5c5c;"></span>Bug (Ghost)</div>
        </div>
    </div>

    <a class="corner-button" href="index.html">Back to Container Lab</a>
    <div class="banner" id="completeBanner">Task Complete - Re-seeding level</div>
    <div class="debug-panel" id="debugPanel"></div>
    <div class="hat-panel" id="hatPanel">
        <h3>Equipped Hats</h3>
        <div id="hatList"></div>
    </div>
    <div class="tutorial-overlay" id="tutorialOverlay" aria-hidden="true">
        <div class="tutorial-card" role="dialog" aria-modal="true" aria-labelledby="tutorialTitle">
            <h2 id="tutorialTitle">Automation Insight</h2>
            <p id="tutorialMessage"></p>
            <button id="tutorialOk">OK, continue</button>
        </div>
    </div>
    <div class="hat-select-overlay" id="hatSelectOverlay" aria-hidden="true">
        <div class="hat-select-card" role="dialog" aria-modal="true" aria-labelledby="hatSelectTitle">
            <h2 id="hatSelectTitle">Equip Hat Loadout</h2>
            <p>Select the initial tools for this slave container. Each hat has limited charge that refills slowly as chains complete.</p>
            <div class="hat-options" id="hatOptions">
                <label class="hat-option"><input type="checkbox" value="speed" checked> Script Hat (speed boost)</label>
                <label class="hat-option"><input type="checkbox" value="wall"> Phase Hat (pass through walls)</label>
                <label class="hat-option"><input type="checkbox" value="paint"> Wrench Override (change dot color)</label>
                <label class="hat-option"><input type="checkbox" value="zap"> Red-Eye Zap (clear bugs)</label>
            </div>
            <button id="hatSelectConfirm">Deploy Container</button>
        </div>
    </div>

    <script>
        (() => {
            const canvas = document.getElementById('playgroundCanvas');
            const ctx = canvas.getContext('2d');
            const statusText = document.getElementById('statusText');
            const scoreValue = document.getElementById('scoreValue');
            const levelValue = document.getElementById('levelValue');
            const livesValue = document.getElementById('livesValue');
            const timeValue = document.getElementById('timeValue');
            const chainValue = document.getElementById('chainValue');
            const nextValue = document.getElementById('nextValue');
            const chainRow = document.getElementById('chainRow');
            const narrationText = document.getElementById('narrationText');
            const banner = document.getElementById('completeBanner');
            const badge = document.getElementById('containerBadge');
            const hudTitle = document.querySelector('.hud h1');
            const hudDescription = document.querySelector('.hud p');
            const debugPanel = document.getElementById('debugPanel');
            const hatPanel = document.getElementById('hatPanel');
            const hatList = document.getElementById('hatList');
            const tutorialOverlay = document.getElementById('tutorialOverlay');
            const tutorialTitle = document.getElementById('tutorialTitle');
            const tutorialMessage = document.getElementById('tutorialMessage');
            const tutorialOk = document.getElementById('tutorialOk');
            const hatSelectOverlay = document.getElementById('hatSelectOverlay');
            const hatSelectConfirm = document.getElementById('hatSelectConfirm');
            const hatOptions = document.getElementById('hatOptions');
            const params = new URLSearchParams(window.location.search);
            const roleParam = (params.get('role') || 'slave').toLowerCase();
            const debugEnabled = params.get('debug') === '1';
            const safeEnabled = params.get('safe') === '1';
            const roleConfigs = {
                slave: { label: 'Slave Container', levels: [1, 2, 3, 4, 5], nextRole: 'servant' },
                servant: { label: 'Servant Container', levels: [2, 3, 4], nextRole: null }
            };
            const roleKey = roleConfigs[roleParam] ? roleParam : 'slave';
            const roleConfig = roleConfigs[roleKey];
            const rawContainer = parseInt(params.get('container') || '1', 10) || 1;
            const containerIndex = Math.min(Math.max(1, rawContainer), roleConfig.levels.length);
            const levelParam = Number(params.get('level'));
            const selectedLevel = Number.isFinite(levelParam) && levelParam > 0
                ? levelParam
                : (roleConfig.levels[containerIndex - 1] || roleConfig.levels[0] || 1);

            const layout = [
                '###################',
                '#........#........#',
                '#.###.###.#.###.###',
                '#o###.###.#.###.###',
                '#.................#',
                '#.###.#.#####.#.###',
                '#.....#...#...#...#',
                '#####.###.#.###.###',
                '#........#........#',
                '#.###.###.#.###.###',
                '#...#.....#.......#',
                '#.###.###.#.###.###',
                '#........#........#',
                '#####.###.#.###.###',
                '#.....#...#...#...#',
                '#.###.#.#####.#.###',
                '#.................#',
                '#o###.###.#.###.###',
                '#.###.###.#.###.###',
                '#........#........#',
                '###################'
            ];

            const chainSequence = [
                { key: 'red', label: 'Executing Script', color: '#e74c3c', points: 12 },
                { key: 'orange', label: 'Utilizing Tool', color: '#f39c12', points: 14 },
                { key: 'yellow', label: 'Accessing MCP', color: '#f1c40f', points: 16 },
                { key: 'blue', label: 'Utilizing Skill', color: '#3498db', points: 18 },
                { key: 'green', label: 'Validating Output', color: '#2ecc71', points: 20 },
                { key: 'brown', label: 'Persisting State', color: '#8e5b3a', points: 22 },
                { key: 'black', label: 'Finalizing Run', color: '#2d3436', points: 24 }
            ];

            const powerNode = { key: 'power', label: 'Tool Access', color: '#ff7675', points: 30 };
            const boostNode = { key: 'boost', label: 'Script Boost', color: '#00cec9', points: 40, duration: 5000, speedBonus: 1.4 };

            const toolConfigs = {
                speed: { label: 'Script Hat', color: '#74b9ff', duration: 5000, speedBonus: 1.6, cost: 15 },
                wall: { label: 'Phase Hat', color: '#3498db', duration: 4500, cost: 30 },
                paint: { label: 'Wrench Override', color: '#f39c12', cost: 20 },
                zap: { label: 'Red-Eye Zap', color: '#e74c3c', cost: 25 }
            };
            const hatChargeConfig = {
                start: 40,
                perChain: 1,
                comboBonus: 1,
                powerBonus: 25,
                boostBonus: 30,
                comboWindowMs: 3500
            };

            const sound = {
                enabled: true,
                ctx: null
            };

            const levelConfigs = [
                {
                    id: 1,
                    name: 'Sequence Primer',
                    title: 'Autonomous Task Runner',
                    summary: 'Three mini-chains demonstrate build, validate, and finalize loops.',
                    chainSets: [
                        ['red', 'orange', 'yellow'],
                        ['blue', 'green', 'brown'],
                        ['red', 'orange', 'black']
                    ],
                    chainKeys: ['red', 'orange', 'yellow', 'blue', 'green', 'brown', 'black'],
                    tutorialKeys: ['red', 'orange', 'yellow', 'blue', 'green', 'brown', 'black'],
                    ghostCount: 0,
                    allowPowerNodes: false,
                    allowBoostNodes: false,
                    bugsEnabled: false,
                    autoMistake: false,
                    speedMultiplier: 1,
                    narration: [
                        'Primer level: three rotating task chains run in sequence.',
                        'No bugs here. Focus on understanding why order matters.',
                        'Each dot is a task step inside a sealed container.'
                    ]
                },
                {
                    id: 2,
                    name: 'Tooling Path',
                    title: 'Tool Access & Wildcards',
                    summary: 'Power nodes unlock tools that can preserve the chain.',
                    chainKeys: ['red', 'orange', 'yellow', 'blue'],
                    tutorialKeys: ['blue', 'power'],
                    ghostCount: 1,
                    allowPowerNodes: true,
                    allowBoostNodes: false,
                    bugsEnabled: true,
                    autoMistake: false,
                    speedMultiplier: 1,
                    narration: [
                        'Power nodes grant tools that can skip chain steps.',
                        'Blue dots mark skill execution in this sequence.',
                        'Tools reduce bug impact when the chain slips.'
                    ]
                },
                {
                    id: 3,
                    name: 'Bug Mitigation',
                    title: 'Bug Containment',
                    summary: 'Bugs enter the maze; boosts keep execution fast.',
                    chainKeys: ['red', 'orange', 'yellow', 'blue', 'green'],
                    ghostCount: 2,
                    allowPowerNodes: true,
                    allowBoostNodes: true,
                    bugsEnabled: true,
                    autoMistake: false,
                    speedMultiplier: 1.05,
                    narration: [
                        'Bugs now patrol the container lanes.',
                        'Script boosts accelerate execution when timing matters.',
                        'Green dots confirm validation before the next step.'
                    ]
                },
                {
                    id: 4,
                    name: 'Full Pipeline',
                    title: 'Workflow Orchestration',
                    summary: 'Full chain, more bugs, and an intentional mis-order demo.',
                    chainKeys: ['red', 'orange', 'yellow', 'blue', 'green', 'brown', 'black'],
                    ghostCount: 3,
                    allowPowerNodes: true,
                    allowBoostNodes: true,
                    bugsEnabled: true,
                    autoMistake: true,
                    mistakeIntervalMs: 16000,
                    mistakeWindowMs: 7000,
                    speedMultiplier: 1.08,
                    narration: [
                        'Full pipeline: all seven steps are required.',
                        'Autopilot will occasionally show a mis-order to trigger bugs.',
                        'Brown and black finalize persistence and handoff.'
                    ]
                },
                {
                    id: 5,
                    name: 'Stress Test',
                    title: 'High-Pressure Execution',
                    summary: 'All systems active with higher bug pressure and faster pacing.',
                    chainKeys: ['red', 'orange', 'yellow', 'blue', 'green', 'brown', 'black'],
                    ghostCount: 4,
                    allowPowerNodes: true,
                    allowBoostNodes: true,
                    bugsEnabled: true,
                    autoMistake: true,
                    mistakeIntervalMs: 11000,
                    mistakeWindowMs: 6000,
                    speedMultiplier: 1.16,
                    narration: [
                        'Stress test shows peak load handling.',
                        'Mistakes trigger aggressive bug surges.',
                        'Tools and boosts keep throughput steady.'
                    ]
                }
            ];

            const baseNarrationScript = [
                'Dots follow the chain order: red > orange > yellow > blue > green > brown > black.',
                'Power nodes grant limited-use hats that unlock special abilities.',
                'Bugs react to mistakes. Higher chain errors can trigger bug surges.',
                'Script boosts speed execution and helps finish chains faster.',
                'This autoplay demo mirrors agent workflows without exposing private data.'
            ];

            const tutorialMessages = {
                intro: {
                    title: 'Autopilot Overview',
                    body: 'This demo shows a container agent executing a strict task chain. The robot must collect dots in order to keep workflows deterministic and repeatable.'
                },
                red: {
                    title: 'Executing Script',
                    body: 'The first dot represents a controlled script run. It sets the baseline context before tools or external services are used.'
                },
                orange: {
                    title: 'Utilizing Tool',
                    body: 'Tool access is scoped and deliberate. This step shows the agent invoking a tool only when the chain requires it.'
                },
                yellow: {
                    title: 'Accessing MCP',
                    body: 'MCP access pulls the right context at the right time. Following the chain reduces errors and keeps output trustworthy.'
                },
                power: {
                    title: 'Tool Access',
                    body: 'Tool access equips a slave agent with targeted capabilities (scripts, overrides, bug fixes) that shorten execution time and keep workflows stable. In this demo, that idea is visualized as limited-use hats.'
                },
                boost: {
                    title: 'Script Boost',
                    body: 'Script boosts speed execution and reduce time spent between chain steps.'
                },
                blue: {
                    title: 'Utilizing Skill',
                    body: 'Skills apply domain expertise to the task. This chain step represents specialized execution.'
                },
                green: {
                    title: 'Validating Output',
                    body: 'Validation confirms results before anything is persisted or finalized.'
                },
                brown: {
                    title: 'Persisting State',
                    body: 'State is stored only after validation passes to keep the system consistent.'
                },
                black: {
                    title: 'Finalizing Run',
                    body: 'Finalization seals the workflow and marks the task as complete.'
                }
            };

            const state = {
                width: 0,
                height: 0,
                levelRect: { x: 0, y: 0, w: 0, h: 0 },
                cols: layout[0].length,
                rows: layout.length,
                cellSize: 0,
                walls: new Set(),
                dots: [],
                dotMap: new Map(),
                activeChainSequence: [],
                allowedChainSequence: null,
                chainSets: null,
                chainSetIndex: 0,
                narrationScript: baseNarrationScript,
                levelConfig: null,
                autoMistakeTargetKey: null,
                autoMistakeUntil: 0,
                nextMistakeAt: 0,
                lastPosition: { c: 0, r: 0 },
                stuckSince: 0,
                tutorialQueue: [],
                tutorialActive: false,
                tutorialShown: {},
                modalAction: null,
                bugThreatUntil: 0,
                inefficiencyCooldownUntil: 0,
                safeMode: safeEnabled,
                player: {
                    c: 1,
                    r: 1,
                    dirX: 1,
                    dirY: 0,
                    heading: 0,
                    baseSpeed: 4.2
                },
                ghosts: [],
                autopilot: true,
                playerMode: false,
                eatHeld: false,
                paused: false,
                autoPath: [],
                autoStep: 0,
                score: 0,
                level: 1,
                lives: 3,
                hatCharges: {
                    speed: 0,
                    wall: 0,
                    paint: 0,
                    zap: 0
                },
                equippedHats: [],
                wallPassUntil: 0,
                chainIndex: 0,
                chainStreak: 0,
                chainStartTime: 0,
                lastChainTime: 0,
                speedBoostUntil: 0,
                bugBoostUntil: 0,
                bugBoostFactor: 1,
                frightenedUntil: 0,
                mode: 'scatter',
                modeTimer: 0,
                lastTime: 0,
                freezeUntil: 0,
                narrationIndex: 0,
                narrationHoldUntil: 0,
                narrationTimer: 0,
                recoveryMode: false,
                savedChainSequence: null,
                savedChainSetIndex: 0,
                zapFlashUntil: 0,
                runStartTime: 0
            };

            const ghostConfigs = [
                { id: 'bug-alpha', color: '#ff5c5c', personality: 'chase' },
                { id: 'bug-beta', color: '#6dd5fa', personality: 'ambush' },
                { id: 'bug-gamma', color: '#f093fb', personality: 'random' },
                { id: 'bug-delta', color: '#feca57', personality: 'guard' }
            ];

            function unlockAudio() {
                if (!sound.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    sound.ctx = new AudioContext();
                }
                if (sound.ctx.state === 'suspended') {
                    sound.ctx.resume();
                }
            }

            function playTone(freq, duration, type, gainValue) {
                if (!sound.enabled || !sound.ctx) return;
                const ctx = sound.ctx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const now = ctx.currentTime;
                osc.type = type || 'sine';
                osc.frequency.value = freq;
                gain.gain.value = 0.0001;
                gain.gain.linearRampToValueAtTime(gainValue || 0.08, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + duration + 0.02);
            }

            function playEvent(name) {
                const map = {
                    chain: { freq: 520, duration: 0.08 },
                    complete: { freq: 760, duration: 0.12 },
                    power: { freq: 640, duration: 0.1 },
                    tool: { freq: 420, duration: 0.09 },
                    break: { freq: 180, duration: 0.14 },
                    bug: { freq: 130, duration: 0.18 }
                };
                const setting = map[name] || { freq: 440, duration: 0.08 };
                playTone(setting.freq, setting.duration, 'triangle', 0.07);
            }

            function grantHatCharge(preferKey, amountOverride) {
                const available = state.equippedHats.length ? state.equippedHats : Object.keys(toolConfigs);
                const pick = preferKey && available.includes(preferKey)
                    ? preferKey
                    : available.reduce((lowest, keyName) => {
                        const charge = state.hatCharges[keyName] || 0;
                        const lowestCharge = state.hatCharges[lowest] || 0;
                        return charge < lowestCharge ? keyName : lowest;
                    }, available[0]);
                if (!pick) return;
                const amount = amountOverride ?? hatChargeConfig.powerBonus;
                state.hatCharges[pick] = Math.min(100, (state.hatCharges[pick] || 0) + amount);
                const label = toolConfigs[pick]?.label || 'Hat';
                showBanner(`${label} Charged`);
                playEvent('power');
                setNarration(`${label} charged. Limited power available.`);
                updateHud();
            }

            function useSpeedTool(now) {
                if (state.hatCharges.speed < toolConfigs.speed.cost) return false;
                state.hatCharges.speed -= toolConfigs.speed.cost;
                state.speedBoostUntil = now + toolConfigs.speed.duration;
                showBanner('Script Hat: Speed Boost');
                playEvent('tool');
                setNarration('Script hat engaged. Execution speed increased.');
                updateHud();
                return true;
            }

            function useWallTool(now) {
                if (state.hatCharges.wall < toolConfigs.wall.cost) return false;
                state.hatCharges.wall -= toolConfigs.wall.cost;
                state.wallPassUntil = now + toolConfigs.wall.duration;
                state.autoPath = [];
                state.autoStep = 0;
                showBanner('Phase Hat: Wall Pass');
                playEvent('tool');
                setNarration('Phase hat active. Passing through walls temporarily.');
                updateHud();
                return true;
            }

            function useZapTool(now) {
                if (state.hatCharges.zap < toolConfigs.zap.cost) return false;
                if (!state.ghosts.length) return false;
                let closest = state.ghosts[0];
                let bestDist = Math.hypot(state.player.c - closest.c, state.player.r - closest.r);
                state.ghosts.forEach((ghost) => {
                    const dist = Math.hypot(state.player.c - ghost.c, state.player.r - ghost.r);
                    if (dist < bestDist) {
                        bestDist = dist;
                        closest = ghost;
                    }
                });
                if (bestDist > 4) return false;
                state.hatCharges.zap -= toolConfigs.zap.cost;
                const spawn = findOpenCell(Math.floor(state.cols / 2), Math.floor(state.rows / 2));
                closest.c = spawn.c;
                closest.r = spawn.r;
                closest.dirX = 0;
                closest.dirY = -1;
                closest.heading = -Math.PI / 2;
                state.zapFlashUntil = now + 400;
                state.frightenedUntil = Math.max(state.frightenedUntil, now + 1500);
                state.bugThreatUntil = Math.max(0, state.bugThreatUntil - 1500);
                showBanner('Red-Eye Zap: Bug Cleared');
                playEvent('tool');
                setNarration('Bug zapped. Threat window reduced.');
                updateHud();
                return true;
            }

            function useToolAuto(now, force) {
                if (!state.safeMode && state.bugThreatUntil > now && state.hatCharges.zap >= toolConfigs.zap.cost) {
                    if (useZapTool(now)) return true;
                }
                if (state.hatCharges.speed >= toolConfigs.speed.cost && state.speedBoostUntil < now) {
                    if (useSpeedTool(now)) return true;
                }
                if (state.hatCharges.wall >= toolConfigs.wall.cost && state.wallPassUntil < now) {
                    if (force || state.autoPath.length > 18) {
                        if (useWallTool(now)) return true;
                    }
                }
                return false;
            }

            function getActiveChainSequence() {
                if (state.activeChainSequence && state.activeChainSequence.length) {
                    return state.activeChainSequence;
                }
                return chainSequence;
            }

            function scheduleNextMistake(now) {
                if (!state.levelConfig || !state.levelConfig.autoMistake) {
                    state.nextMistakeAt = 0;
                    return;
                }
                const base = state.levelConfig.mistakeIntervalMs || 14000;
                const jitter = base * 0.3 * Math.random();
                state.nextMistakeAt = now + base + jitter;
            }

            function applyLevelConfig() {
                const config = levelConfigs.find((entry) => entry.id === selectedLevel) || levelConfigs[0];
                state.levelConfig = config;
                state.chainSets = Array.isArray(config.chainSets) ? config.chainSets : null;
                state.chainSetIndex = 0;
                if (state.chainSets && state.chainSets.length) {
                    const allowedKeys = new Set();
                    state.chainSets.forEach((setKeys) => {
                        if (Array.isArray(setKeys)) {
                            setKeys.forEach((keyName) => allowedKeys.add(keyName));
                        }
                    });
                    state.allowedChainSequence = chainSequence.filter((entry) => allowedKeys.has(entry.key));
                    const firstSet = state.chainSets[0] || [];
                    state.activeChainSequence = chainSequence.filter((entry) => firstSet.includes(entry.key));
                } else {
                    state.allowedChainSequence = null;
                    state.activeChainSequence = chainSequence.filter((entry) => config.chainKeys.includes(entry.key));
                }
                if (!state.activeChainSequence.length) {
                    state.activeChainSequence = chainSequence.slice();
                }
                state.playerMode = false;
                state.autopilot = true;
                state.eatHeld = false;
                state.player.baseSpeed = 5.4 * (config.speedMultiplier || 1);
                state.hatCharges = { speed: 0, wall: 0, paint: 0, zap: 0 };
                state.equippedHats = [];
                updateHatPanel();
                state.wallPassUntil = 0;
                state.autoMistakeTargetKey = null;
                state.autoMistakeUntil = 0;
                scheduleNextMistake(performance.now());
                state.narrationScript = config.narration && config.narration.length
                    ? config.narration
                    : baseNarrationScript;
                state.narrationIndex = 0;
                state.narrationTimer = 0;
                state.tutorialQueue = [];
                state.tutorialActive = false;
                state.tutorialShown = {};
                state.recoveryMode = false;
                state.savedChainSequence = null;
                state.savedChainSetIndex = 0;
                state.runStartTime = performance.now();
                showHatSelect();
                if (config.id === 1) {
                    const intro = tutorialMessages.intro;
                    if (intro) enqueueTutorial(intro.body, intro.title);
                }
                if (badge) {
                    badge.textContent = `${roleConfig.label} ${containerIndex} - ${config.name}`;
                }
                if (hudTitle) {
                    hudTitle.textContent = config.title;
                }
                if (hudDescription) {
                    hudDescription.textContent = config.summary;
                }
            }

            function initChainRow() {
                chainRow.innerHTML = '';
                getActiveChainSequence().forEach((entry, index) => {
                    const dot = document.createElement('span');
                    dot.className = 'chain-dot';
                    dot.dataset.index = index;
                    dot.style.backgroundColor = entry.color;
                    dot.style.color = entry.color;
                    chainRow.appendChild(dot);
                });
            }

            function updateChainDisplay() {
                const sequence = getActiveChainSequence();
                const expected = getExpectedKey();
                const expectedEntry = sequence.find((entry) => entry.key === expected) || chainSequence[0];
                nextValue.textContent = expectedEntry.label;
                if (state.chainSets && state.chainSets.length) {
                    chainValue.textContent = `${state.chainIndex}/${sequence.length} (Set ${state.chainSetIndex + 1}/${state.chainSets.length})`;
                } else {
                    chainValue.textContent = `${state.chainIndex}/${sequence.length}`;
                }
                Array.from(chainRow.children).forEach((dot, index) => {
                    dot.classList.remove('active', 'completed');
                    if (index < state.chainIndex) {
                        dot.classList.add('completed');
                    }
                    if (index === state.chainIndex) {
                        dot.classList.add('active');
                    }
                });
            }

            function showBanner(message, duration) {
                banner.textContent = message;
                banner.classList.add('visible');
                setTimeout(() => {
                    banner.classList.remove('visible');
                }, duration || 1400);
            }

            function setNarration(message, holdMs) {
                if (!narrationText) return;
                narrationText.textContent = message;
                state.narrationHoldUntil = performance.now() + (holdMs || 2600);
            }

            function updateNarration(delta, now) {
                if (state.playerMode || !narrationText) return;
                if (now < state.narrationHoldUntil) return;
                state.narrationTimer += delta;
                if (state.narrationTimer >= 6) {
                    state.narrationTimer = 0;
                    const script = state.narrationScript || baseNarrationScript;
                    if (!script.length) return;
                    state.narrationIndex = (state.narrationIndex + 1) % script.length;
                    narrationText.textContent = script[state.narrationIndex];
                }
            }

            function enqueueTutorial(message, title) {
                if (!message || !tutorialOverlay) return;
                state.tutorialQueue.push({ message, title: title || 'Automation Insight' });
                if (!state.tutorialActive) {
                    showNextTutorial();
                }
            }

            function showNextTutorial() {
                const next = state.tutorialQueue.shift();
                if (!next) {
                    state.tutorialActive = false;
                    return;
                }
                state.tutorialActive = true;
                state.paused = true;
                tutorialTitle.textContent = next.title;
                tutorialMessage.textContent = next.message;
                tutorialOk.textContent = 'OK, continue';
                state.modalAction = null;
                tutorialOverlay.classList.add('visible');
                tutorialOverlay.setAttribute('aria-hidden', 'false');
            }

            function dismissTutorial() {
                if (!tutorialOverlay || !state.tutorialActive) return;
                tutorialOverlay.classList.remove('visible');
                tutorialOverlay.setAttribute('aria-hidden', 'true');
                state.paused = false;
                state.tutorialActive = false;
                if (state.chainIndex > 0) {
                    state.lastChainTime = performance.now();
                }
                if (state.modalAction) {
                    const action = state.modalAction;
                    state.modalAction = null;
                    action();
                    return;
                }
                if (state.tutorialQueue.length) {
                    showNextTutorial();
                }
            }

            function showModal(message, title, buttonLabel, action) {
                if (!tutorialOverlay) return;
                state.tutorialQueue = [];
                state.tutorialActive = true;
                state.paused = true;
                state.modalAction = typeof action === 'function' ? action : null;
                tutorialTitle.textContent = title || 'Automation Insight';
                tutorialMessage.textContent = message;
                tutorialOk.textContent = buttonLabel || 'OK, continue';
                tutorialOverlay.classList.add('visible');
                tutorialOverlay.setAttribute('aria-hidden', 'false');
            }

            function showHatSelect() {
                if (!hatSelectOverlay) return;
                state.paused = true;
                hatSelectOverlay.classList.add('visible');
                hatSelectOverlay.setAttribute('aria-hidden', 'false');
            }

            function applyHatSelection() {
                if (!hatOptions) return;
                const selected = Array.from(hatOptions.querySelectorAll('input[type="checkbox"]'))
                    .filter((input) => input.checked)
                    .map((input) => input.value);
                if (!selected.length) {
                    selected.push('speed');
                }
                state.equippedHats = selected;
                resetHatCharges();
                state.runStartTime = performance.now();
                hatSelectOverlay.classList.remove('visible');
                hatSelectOverlay.setAttribute('aria-hidden', 'true');
                state.paused = false;
                updateHud();
            }

            function maybeShowTutorialForDot(dotType) {
                if (!state.levelConfig) return;
                if (state.levelConfig.tutorialKeys && !state.levelConfig.tutorialKeys.includes(dotType)) {
                    return;
                }
                if (state.tutorialShown[dotType]) return;
                const entry = tutorialMessages[dotType];
                if (!entry) return;
                state.tutorialShown[dotType] = true;
                enqueueTutorial(entry.body, entry.title);
            }

            function resize() {
                const dpr = window.devicePixelRatio || 1;
                state.width = canvas.clientWidth;
                state.height = canvas.clientHeight;
                canvas.width = Math.floor(state.width * dpr);
                canvas.height = Math.floor(state.height * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                const padding = Math.min(state.width, state.height) * 0.08;
                const gridW = state.width - padding * 2;
                const gridH = state.height - padding * 2;
                state.cellSize = Math.floor(Math.min(gridW / state.cols, gridH / state.rows));
                const levelW = state.cellSize * state.cols;
                const levelH = state.cellSize * state.rows;
                state.levelRect = {
                    x: (state.width - levelW) / 2,
                    y: (state.height - levelH) / 2,
                    w: levelW,
                    h: levelH
                };
                buildLevel();
            }

            function buildLevel() {
                state.walls.clear();
                state.dots = [];
                state.dotMap.clear();
                let dotIndex = 0;
                let nodeIndex = 0;
                const sequence = state.allowedChainSequence && state.allowedChainSequence.length
                    ? state.allowedChainSequence
                    : getActiveChainSequence();
                const allowPowerNodes = state.levelConfig ? state.levelConfig.allowPowerNodes : true;
                const allowBoostNodes = state.levelConfig ? state.levelConfig.allowBoostNodes : false;

                layout.forEach((row, r) => {
                    for (let c = 0; c < row.length; c++) {
                        const tile = row[c];
                        if (tile === '#') {
                            state.walls.add(key(c, r));
                            continue;
                        }
                        if (tile === '.' || tile === 'o') {
                            if (tile === 'o' && allowPowerNodes) {
                                const nodeType = allowBoostNodes && nodeIndex % 2 === 1 ? boostNode.key : powerNode.key;
                                const nodePoints = nodeType === boostNode.key ? boostNode.points : powerNode.points;
                                const dot = { c, r, active: true, type: nodeType, points: nodePoints, isNode: true };
                                state.dots.push(dot);
                                state.dotMap.set(key(c, r), dot);
                                nodeIndex += 1;
                            } else {
                                const pick = sequence[dotIndex % sequence.length] || chainSequence[0];
                                const dot = { c, r, active: true, type: pick.key, points: pick.points, isNode: false };
                                state.dots.push(dot);
                                state.dotMap.set(key(c, r), dot);
                                dotIndex += 1;
                            }
                        }
                    }
                });

                state.chainIndex = 0;
                state.chainStreak = 0;
                state.chainStartTime = 0;
                state.lastChainTime = 0;
                resetHatCharges();
                state.frightenedUntil = 0;
                state.speedBoostUntil = 0;
                state.wallPassUntil = 0;
                state.bugBoostUntil = 0;
                state.bugBoostFactor = 1;
                state.recoveryMode = false;
                state.savedChainSequence = null;
                state.savedChainSetIndex = 0;
                state.bugThreatUntil = 0;
                state.inefficiencyCooldownUntil = 0;
                state.autoMistakeTargetKey = null;
                state.autoMistakeUntil = 0;
                scheduleNextMistake(performance.now());
                resetPositions();
                updateHud();
            }

            function resetPositions() {
                const start = findOpenCell(1, state.rows - 2);
                state.player.c = start.c;
                state.player.r = start.r;
                state.player.dirX = 1;
                state.player.dirY = 0;
                state.player.heading = 0;
                state.autoPath = [];
                state.autoStep = 0;
                resetGhosts();
                primeAutopilot();
            }

            function resetGhosts() {
                const spawnPoints = [
                    findOpenCell(Math.floor(state.cols / 2), Math.floor(state.rows / 2) - 1),
                    findOpenCell(Math.floor(state.cols / 2) - 1, Math.floor(state.rows / 2)),
                    findOpenCell(Math.floor(state.cols / 2) + 1, Math.floor(state.rows / 2)),
                    findOpenCell(Math.floor(state.cols / 2), Math.floor(state.rows / 2) + 1)
                ];
                const ghostCount = Math.max(0, Math.min(
                    state.levelConfig ? state.levelConfig.ghostCount : ghostConfigs.length,
                    ghostConfigs.length
                ));
                state.ghosts = ghostConfigs.slice(0, ghostCount).map((config, index) => {
                    const spawn = spawnPoints[index % spawnPoints.length];
                    return {
                        ...config,
                        c: spawn.c,
                        r: spawn.r,
                        dirX: 0,
                        dirY: -1,
                        heading: -Math.PI / 2,
                        speed: 3.2 + Math.min(state.level * 0.1, 0.8)
                    };
                });
            }

            function key(c, r) {
                return `${c},${r}`;
            }

            function isWall(c, r) {
                if (c < 0 || r < 0 || c >= state.cols || r >= state.rows) {
                    return true;
                }
                return state.walls.has(key(c, r));
            }

            function isOutOfBounds(c, r) {
                return c < 0 || r < 0 || c >= state.cols || r >= state.rows;
            }

            function findOpenCell(c, r) {
                if (!isWall(c, r)) return { c, r };
                for (let radius = 1; radius < 6; radius++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nc = c + dx;
                            const nr = r + dy;
                            if (nc < 0 || nr < 0 || nc >= state.cols || nr >= state.rows) continue;
                            if (!isWall(nc, nr)) return { c: nc, r: nr };
                        }
                    }
                }
                return { c, r };
            }

            function updateHud() {
                const modeLabel = state.playerMode ? 'Player' : 'Demo';
                const scenario = state.levelConfig ? state.levelConfig.name : 'Demo';
                const safeLabel = state.safeMode ? 'On' : 'Off';
                statusText.textContent = `Mode: ${modeLabel} | Autopilot: ${state.autopilot ? 'On' : 'Off'} | Role: ${roleConfig.label} | Safe: ${safeLabel} | Scenario: ${scenario} | Remaining: ${remainingDots()}`;
                scoreValue.textContent = state.score;
                levelValue.textContent = state.level;
                livesValue.textContent = state.lives;
                if (timeValue) {
                    timeValue.textContent = formatTime(performance.now() - state.runStartTime);
                }
                updateChainDisplay();
                updateHatPanel();
            }

            function totalHatCharge() {
                return Object.values(state.hatCharges).reduce((sum, count) => sum + count, 0);
            }

            function formatHatCharges() {
                return `S${state.hatCharges.speed} W${state.hatCharges.wall} C${state.hatCharges.paint} Z${state.hatCharges.zap}`;
            }

            function formatTime(ms) {
                const totalSeconds = Math.max(0, Math.floor(ms / 1000));
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            function resetHatCharges() {
                Object.keys(state.hatCharges).forEach((key) => {
                    state.hatCharges[key] = state.equippedHats.includes(key) ? hatChargeConfig.start : 0;
                });
                updateHatPanel();
            }

            function rechargeHats(amount) {
                if (!state.equippedHats.length) return;
                state.equippedHats.forEach((key) => {
                    state.hatCharges[key] = Math.min(100, (state.hatCharges[key] || 0) + amount);
                });
                updateHatPanel();
            }

            function updateHatPanel() {
                if (!hatList) return;
                const hats = state.equippedHats || [];
                hatList.innerHTML = '';
                if (!hats.length) {
                    const empty = document.createElement('div');
                    empty.className = 'hat-empty';
                    empty.textContent = 'No hats equipped yet.';
                    hatList.appendChild(empty);
                    return;
                }
                hats.forEach((key) => {
                    const config = toolConfigs[key];
                    const charge = Math.round(state.hatCharges[key] || 0);
                    const row = document.createElement('div');
                    row.className = 'hat-row';
                    row.innerHTML = `
                        <div class="hat-header">
                            <span>${config.label}</span>
                            <span>${charge}%</span>
                        </div>
                        <div class="hat-bar">
                            <div class="hat-fill" style="width:${charge}%; background:${config.color};"></div>
                        </div>
                    `;
                    hatList.appendChild(row);
                });
            }

            function updateDebug(now) {
                if (!debugPanel || !debugEnabled) return;
                const expectedKey = getExpectedKey();
                const pos = `${state.player.c.toFixed(2)}, ${state.player.r.toFixed(2)}`;
                const dir = `${state.player.dirX}, ${state.player.dirY}`;
                const freezeLeft = Math.max(0, Math.round((state.freezeUntil - now) / 100) / 10);
                const autoTarget = state.autoMistakeTargetKey ? state.autoMistakeTargetKey : 'none';
                debugPanel.textContent = [
                    `role: ${roleKey} | autopilot: ${state.autopilot} | player: ${state.playerMode} | safe: ${state.safeMode}`,
                    `pos: ${pos} | dir: ${dir}`,
                    `expected: ${expectedKey} | chain: ${state.chainIndex}/${getActiveChainSequence().length}`,
                    `path: ${state.autoPath.length} | step: ${state.autoStep} | target: ${state.targetCell ? `${state.targetCell.c},${state.targetCell.r}` : 'none'}`,
                    `hats: ${formatHatCharges()} | wall pass: ${Math.max(0, Math.round((state.wallPassUntil - now) / 100) / 10)}s`,
                    `ghosts: ${state.ghosts.length} | freeze: ${freezeLeft}s | bug window: ${Math.max(0, Math.round((state.bugThreatUntil - now) / 100) / 10)}s`,
                    `mistake target: ${autoTarget}`
                ].join('\n');
            }

            function remainingDots() {
                return state.dots.filter((dot) => dot.active && !dot.isNode).length;
            }

            function hasDotOfType(typeKey) {
                return state.dots.some((dot) => dot.active && dot.type === typeKey);
            }

            function getMistakeDotType(expectedKey) {
                const sequence = getActiveChainSequence();
                for (const entry of sequence) {
                    if (entry.key !== expectedKey && hasDotOfType(entry.key)) {
                        return entry.key;
                    }
                }
                return null;
            }

            function getExpectedKey() {
                const sequence = getActiveChainSequence();
                const total = sequence.length;
                for (let offset = 0; offset < total; offset += 1) {
                    const index = (state.chainIndex + offset) % total;
                    const keyName = sequence[index].key;
                    if (hasDotOfType(keyName)) {
                        if (index !== state.chainIndex) {
                            state.chainIndex = index;
                        }
                        return keyName;
                    }
                }
                return sequence[state.chainIndex].key;
            }

            function cellCenter(c, r) {
                const rect = state.levelRect;
                return {
                    x: rect.x + state.cellSize * (c + 0.5),
                    y: rect.y + state.cellSize * (r + 0.5)
                };
            }

            function updateMode(delta) {
                if (state.frightenedUntil > performance.now()) {
                    return;
                }
                state.modeTimer += delta;
                const scatterDuration = 6;
                const chaseDuration = 16;
                if (state.mode === 'scatter' && state.modeTimer >= scatterDuration) {
                    state.mode = 'chase';
                    state.modeTimer = 0;
                }
                if (state.mode === 'chase' && state.modeTimer >= chaseDuration) {
                    state.mode = 'scatter';
                    state.modeTimer = 0;
                }
            }

            function bfsPath(start, targetCheck, allowWalls) {
                const queue = [start];
                const visited = new Set([key(start.c, start.r)]);
                const parent = new Map();
                while (queue.length) {
                    const current = queue.shift();
                    if (targetCheck(current)) {
                        return buildPathFromParent(current, parent);
                    }
                    const neighbors = getNeighbors(current.c, current.r, allowWalls);
                    neighbors.forEach((next) => {
                        const k = key(next.c, next.r);
                        if (visited.has(k)) return;
                        visited.add(k);
                        parent.set(k, current);
                        queue.push(next);
                    });
                }
                return [];
            }

            function buildPathFromParent(end, parent) {
                const path = [end];
                let current = end;
                while (parent.has(key(current.c, current.r))) {
                    current = parent.get(key(current.c, current.r));
                    path.unshift(current);
                }
                return path;
            }

            function getNeighbors(c, r, allowWalls) {
                const options = [
                    { c: c + 1, r, dirX: 1, dirY: 0 },
                    { c: c - 1, r, dirX: -1, dirY: 0 },
                    { c, r: r + 1, dirX: 0, dirY: 1 },
                    { c, r: r - 1, dirX: 0, dirY: -1 }
                ];
                if (allowWalls) {
                    return options.filter((opt) => !isOutOfBounds(opt.c, opt.r));
                }
                return options.filter((opt) => !isWall(opt.c, opt.r));
            }

            function updateAutopilot() {
                if (!state.autopilot) return;
                const cell = { c: Math.round(state.player.c), r: Math.round(state.player.r) };
                const expectedKey = getExpectedKey();
                const hasExpected = hasDotOfType(expectedKey);
                const now = performance.now();
                const allowWalls = state.wallPassUntil > now;
                if (state.autoMistakeTargetKey && now > state.autoMistakeUntil) {
                    state.autoMistakeTargetKey = null;
                    state.autoMistakeUntil = 0;
                }
                const config = state.levelConfig || {};
                const allowBoosts = config.allowBoostNodes !== false;
                const speedEquipped = state.equippedHats.includes('speed');
                const shouldSeekBoost = allowBoosts && speedEquipped && hasDotOfType(boostNode.key)
                    && state.hatCharges.speed < toolConfigs.speed.cost && state.speedBoostUntil < now;
                const shouldMisorder = config.autoMistake
                    && !state.playerMode
                    && !state.autoMistakeTargetKey
                    && state.nextMistakeAt > 0
                    && now >= state.nextMistakeAt;
                const mistakeKey = shouldMisorder ? getMistakeDotType(expectedKey) : null;
                if (!state.autoPath.length || state.autoStep >= state.autoPath.length - 1) {
                    state.autoPath = bfsPath(cell, (node) => {
                        const dot = state.dotMap.get(key(node.c, node.r));
                        if (!dot || !dot.active) return false;
                        if (mistakeKey) {
                            return dot.type === mistakeKey;
                        }
                        if (dot.type === expectedKey) return true;
                        if (dot.type === boostNode.key && shouldSeekBoost) return true;
                        const needsCharge = state.equippedHats.some((keyName) => state.hatCharges[keyName] < toolConfigs[keyName].cost);
                        if (dot.type === powerNode.key && (!hasExpected || needsCharge)) return true;
                        return false;
                    }, allowWalls);
                    state.autoStep = 0;
                    if (mistakeKey && state.autoPath.length) {
                        const target = state.autoPath[state.autoPath.length - 1];
                        state.autoMistakeTargetKey = key(target.c, target.r);
                        state.autoMistakeUntil = now + (config.mistakeWindowMs || 6500);
                        scheduleNextMistake(now);
                        setNarration('Autopilot demo: intentional mis-order to surface bug behavior.', 2400);
                    }
                }
                const next = state.autoPath[state.autoStep + 1];
                if (!next) {
                    const neighbors = getNeighbors(cell.c, cell.r, allowWalls);
                    let fallback = neighbors.find((opt) => {
                        const dot = state.dotMap.get(key(opt.c, opt.r));
                        return dot && dot.active && dot.type === expectedKey;
                    });
                    if (!fallback) {
                        fallback = neighbors[0];
                    }
                    if (fallback) {
                        state.player.dirX = fallback.dirX;
                        state.player.dirY = fallback.dirY;
                        state.targetCell = { c: fallback.c, r: fallback.r };
                    }
                    return;
                }
                const dirX = Math.sign(next.c - cell.c);
                const dirY = Math.sign(next.r - cell.r);
                state.player.dirX = dirX;
                state.player.dirY = dirY;
                state.targetCell = { c: next.c, r: next.r };
            }

            function primeAutopilot() {
                if (!state.autopilot || state.playerMode) return;
                const now = performance.now();
                const allowWalls = state.wallPassUntil > now;
                const cell = { c: Math.round(state.player.c), r: Math.round(state.player.r) };
                const expectedKey = getExpectedKey();
                const currentDot = state.dotMap.get(key(cell.c, cell.r));
                if (currentDot && currentDot.active && currentDot.type === expectedKey) {
                    eatDot(cell.c, cell.r);
                }
                if (state.autoPath.length > 1 && state.autoStep < state.autoPath.length - 1) return;
                const path = bfsPath(cell, (node) => {
                    const dot = state.dotMap.get(key(node.c, node.r));
                    return dot && dot.active && dot.type === expectedKey;
                }, allowWalls);
                if (path.length > 1) {
                    state.autoPath = path;
                    state.autoStep = 0;
                    const next = path[1];
                    state.player.dirX = Math.sign(next.c - cell.c);
                    state.player.dirY = Math.sign(next.r - cell.r);
                    state.targetCell = { c: next.c, r: next.r };
                    return;
                }
                const fallback = bfsPath(cell, (node) => {
                    const dot = state.dotMap.get(key(node.c, node.r));
                    return dot && dot.active;
                }, allowWalls);
                if (fallback.length > 1) {
                    state.autoPath = fallback;
                    state.autoStep = 0;
                    const next = fallback[1];
                    state.player.dirX = Math.sign(next.c - cell.c);
                    state.player.dirY = Math.sign(next.r - cell.r);
                    state.targetCell = { c: next.c, r: next.r };
                }
            }

            function updatePlayer(delta) {
                const now = performance.now();
                const speedBoost = state.speedBoostUntil > now ? toolConfigs.speed.speedBonus : 1;
                const speed = state.player.baseSpeed * speedBoost;

                if (!state.safeMode && (!state.levelConfig || state.levelConfig.bugsEnabled !== false) && state.chainIndex > 0 && state.lastChainTime) {
                    const slowThreshold = 6500;
                    if (now - state.lastChainTime > slowThreshold && now > state.inefficiencyCooldownUntil) {
                        state.inefficiencyCooldownUntil = now + 9000;
                        activateBugThreat(1);
                        showBanner('Efficiency Drop: Bug Risk');
                        setNarration('Efficiency dip detected. Bugs are more likely until the chain resumes.');
                    }
                }

                if (state.autopilot) {
                    if (!state.playerMode) {
                        useToolAuto(now, false);
                    }
                    updateAutopilot();
                    if (!state.targetCell) {
                        primeAutopilot();
                    }
                    if (state.targetCell) {
                        const dx = state.targetCell.c - state.player.c;
                        const dy = state.targetCell.r - state.player.r;
                        const dist = Math.hypot(dx, dy);
                        const step = speed * delta;
                        if (dist > 0) {
                            const ratio = Math.min(1, step / dist);
                            state.player.c += dx * ratio;
                            state.player.r += dy * ratio;
                            state.player.dirX = Math.sign(dx);
                            state.player.dirY = Math.sign(dy);
                            state.player.heading = Math.atan2(dy, dx);
                        }
                        if (dist <= step + 0.001) {
                            state.player.c = state.targetCell.c;
                            state.player.r = state.targetCell.r;
                            const positionKey = key(state.targetCell.c, state.targetCell.r);
                            const dot = state.dotMap.get(positionKey);
                            const expectedKey = getExpectedKey();
                            const canAutoEat = dot && dot.active && (dot.type === expectedKey
                                || dot.type === powerNode.key
                                || dot.type === boostNode.key
                                || (state.autoMistakeTargetKey === positionKey && now <= state.autoMistakeUntil));
                            if (canAutoEat) {
                                if (state.autoMistakeTargetKey === positionKey) {
                                    state.autoMistakeTargetKey = null;
                                    state.autoMistakeUntil = 0;
                                }
                                eatDot(state.targetCell.c, state.targetCell.r);
                            }
                            if (state.autoPath.length > 1) {
                                state.autoStep = Math.min(state.autoStep + 1, state.autoPath.length - 1);
                            }
                            state.targetCell = null;
                        }
                    }

                    const moved = Math.hypot(state.player.c - state.lastPosition.c, state.player.r - state.lastPosition.r) > 0.002;
                    if (moved) {
                        state.lastPosition = { c: state.player.c, r: state.player.r };
                        state.stuckSince = 0;
                    } else if (!state.playerMode) {
                        if (!state.stuckSince) {
                            state.stuckSince = now;
                        } else if (now - state.stuckSince > 1400) {
                            state.autoPath = [];
                            state.autoStep = 0;
                            state.targetCell = null;
                            primeAutopilot();
                            state.stuckSince = now;
                        }
                    }
                    return;
                }

                const nextC = state.player.c + state.player.dirX * speed * delta;
                const nextR = state.player.r + state.player.dirY * speed * delta;
                const canPhase = state.wallPassUntil > now;
                if (!isWall(Math.round(nextC), Math.round(nextR)) || canPhase) {
                    state.player.c = nextC;
                    state.player.r = nextR;
                }

                const snappedC = Math.round(state.player.c);
                const snappedR = Math.round(state.player.r);
                const snapThreshold = 0.04;
                if (Math.abs(state.player.c - snappedC) < snapThreshold && Math.abs(state.player.r - snappedR) < snapThreshold) {
                    state.player.c = snappedC;
                    state.player.r = snappedR;
                    state.player.heading = Math.atan2(state.player.dirY, state.player.dirX);
                    const shouldEat = state.playerMode && state.eatHeld;
                    if (shouldEat) {
                        eatDot(snappedC, snappedR);
                    }
                }
            }

            function eatDot(c, r) {
                const dot = state.dotMap.get(key(c, r));
                if (!dot || !dot.active) return;
                dot.active = false;
                const now = performance.now();
                if (dot.type === powerNode.key) {
                    state.score += powerNode.points;
                    grantHatCharge();
                    maybeShowTutorialForDot('power');
                    return;
                }
                if (dot.type === boostNode.key) {
                    state.score += boostNode.points;
                    grantHatCharge('speed', hatChargeConfig.boostBonus);
                    maybeShowTutorialForDot('boost');
                    return;
                }
                handleChainDot(dot, now);
                updateHud();
                if (remainingDots() === 0) {
                    completeLevel();
                }
            }

            function handleChainDot(dot, now) {
                const expectedKey = getExpectedKey();
                if (dot.type === expectedKey) {
                    applyChainSuccess(dot, now, false);
                    return;
                }
                if (state.hatCharges.paint >= toolConfigs.paint.cost) {
                    usePaintTool(dot, expectedKey, now);
                    return;
                }
                breakChain(dot.type, expectedKey);
            }

            function usePaintTool(dot, expectedKey, now) {
                if (!dot || !expectedKey || state.hatCharges.paint < toolConfigs.paint.cost) return false;
                state.hatCharges.paint -= toolConfigs.paint.cost;
                dot.type = expectedKey;
                showBanner('Wrench Override: Color Shift');
                playEvent('tool');
                setNarration('Wrench applied. Dot color aligned to the chain.');
                updateHud();
                applyChainSuccess(dot, now, true);
                return true;
            }

            function applyChainSuccess(dot, now, usedTool) {
                if (state.chainIndex === 0) {
                    state.chainStartTime = now;
                }
                const stepDelta = state.lastChainTime ? now - state.lastChainTime : null;
                const chainBonus = Math.floor(state.chainStreak * 2);
                const timeBonus = state.lastChainTime ? Math.max(0, Math.round(12 - (now - state.lastChainTime) * 0.006)) : 6;
                const toolPenalty = usedTool ? 6 : 0;
                const points = Math.max(1, dot.points + chainBonus + timeBonus - toolPenalty);
                state.score += points;
                state.chainIndex += 1;
                state.chainStreak = usedTool ? Math.max(0, state.chainStreak - 1) : state.chainStreak + 1;
                state.lastChainTime = now;
                rechargeHats(hatChargeConfig.perChain);
                if (state.chainStreak > 0
                    && state.chainStreak % 5 === 0
                    && stepDelta !== null
                    && stepDelta <= hatChargeConfig.comboWindowMs) {
                    rechargeHats(hatChargeConfig.comboBonus);
                }
                playEvent('chain');
                const sequence = getActiveChainSequence();
                const stepLabel = sequence.find((entry) => entry.key === dot.type)?.label
                    || chainSequence.find((entry) => entry.key === dot.type)?.label
                    || 'Chain Step';
                setNarration(`${stepLabel} complete. ${usedTool ? 'Wildcard applied.' : 'Order maintained.'}`);
                maybeShowTutorialForDot(dot.type);

                if (state.chainIndex >= sequence.length) {
                    const chainDuration = now - state.chainStartTime;
                    const efficiency = Math.max(0, Math.round(300 - chainDuration * 0.05 - totalHatCharge() * 5));
                    const chainBonusScore = 120 + efficiency;
                    state.score += chainBonusScore;
                    showBanner(`Chain Complete +${chainBonusScore}`);
                    playEvent('complete');
                    spawnBonusNodes(1, powerNode);
                    spawnBonusNodes(1, boostNode);
                    setNarration('Chain complete. Container tasks advanced.');
                    state.chainIndex = 0;
                    state.chainStreak = 0;
                    state.chainStartTime = 0;
                    state.lastChainTime = 0;
                    if (state.recoveryMode) {
                        state.recoveryMode = false;
                        state.activeChainSequence = state.savedChainSequence || chainSequence.slice();
                        state.chainSetIndex = state.savedChainSetIndex || 0;
                        state.savedChainSequence = null;
                        state.savedChainSetIndex = 0;
                        initChainRow();
                        showBanner('Recovery Complete');
                        setNarration('Bug resolved. Returning to the primary chain.');
                        updateHud();
                        return;
                    }
                    if (state.chainSets && state.chainSets.length) {
                        state.chainSetIndex = (state.chainSetIndex + 1) % state.chainSets.length;
                        const nextSet = state.chainSets[state.chainSetIndex] || [];
                        state.activeChainSequence = chainSequence.filter((entry) => nextSet.includes(entry.key));
                        if (!state.activeChainSequence.length) {
                            state.activeChainSequence = chainSequence.slice();
                        }
                        initChainRow();
                        showBanner(`Chain Set ${state.chainSetIndex + 1}/${state.chainSets.length}`);
                        updateHud();
                    }
                }
            }

            function breakChain(actualKey, expectedKey) {
                state.chainIndex = 0;
                state.chainStreak = 0;
                state.chainStartTime = 0;
                state.lastChainTime = 0;
                state.autoMistakeTargetKey = null;
                state.autoMistakeUntil = 0;
                scheduleNextMistake(performance.now());
                state.score = Math.max(0, state.score - 8);
                showBanner('Chain Broken');
                playEvent('break');
                const severity = getChainSeverity(actualKey, expectedKey);
                activateBugThreat(severity);
                triggerBugSurge(severity);
                setNarration(`Chain broken. Bugs intensify (severity ${severity}).`);
            }

            function getSequenceIndex(keyName) {
                return getActiveChainSequence().findIndex((entry) => entry.key === keyName);
            }

            function getChainSeverity(actualKey, expectedKey) {
                const total = getActiveChainSequence().length;
                const actualIndex = getSequenceIndex(actualKey);
                const expectedIndex = getSequenceIndex(expectedKey);
                if (actualIndex < 0 || expectedIndex < 0) return 2;
                const diff = (actualIndex - expectedIndex + total) % total;
                const severity = Math.max(1, Math.min(4, diff));
                return severity;
            }

            function triggerBugSurge(severity) {
                if (state.safeMode || (state.levelConfig && state.levelConfig.bugsEnabled === false)) {
                    return;
                }
                const now = performance.now();
                const chance = Math.min(0.2 + 0.12 * severity, 0.85);
                if (Math.random() < chance) {
                    if (state.ghosts.length < 6 && severity >= 2) {
                        spawnExtraGhost();
                        showBanner('Bug Spawned');
                    } else {
                        state.bugBoostUntil = now + 3000 + severity * 600;
                        state.bugBoostFactor = 1 + 0.12 * severity;
                        showBanner('Bug Surge: Severity Increased');
                    }
                }
            }

            function activateBugThreat(severity) {
                if (state.safeMode || (state.levelConfig && state.levelConfig.bugsEnabled === false)) {
                    return;
                }
                const now = performance.now();
                const duration = 4000 + severity * 800;
                state.bugThreatUntil = Math.max(state.bugThreatUntil, now + duration);
            }

            function enterRecoveryMode() {
                if (state.recoveryMode) return;
                state.recoveryMode = true;
                state.savedChainSequence = state.activeChainSequence ? state.activeChainSequence.slice() : null;
                state.savedChainSetIndex = state.chainSetIndex;
                state.chainIndex = 0;
                state.chainStreak = 0;
                state.chainStartTime = 0;
                state.lastChainTime = 0;
                state.activeChainSequence = chainSequence.slice();
                initChainRow();
                showBanner('Bug Recovery: Extended Chain');
                setNarration('Bug detected. Run the extended recovery chain to stabilize.');
            }

            function spawnExtraGhost() {
                const base = ghostConfigs[Math.floor(Math.random() * ghostConfigs.length)];
                const spawn = findOpenCell(Math.floor(state.cols / 2), Math.floor(state.rows / 2));
                state.ghosts.push({
                    ...base,
                    id: `${base.id}-${state.ghosts.length + 1}`,
                    c: spawn.c,
                    r: spawn.r,
                    dirX: 0,
                    dirY: -1,
                    heading: -Math.PI / 2,
                    speed: 3.3
                });
            }

            function spawnBonusNodes(count, nodeType) {
                if (nodeType === powerNode && state.levelConfig && !state.levelConfig.allowPowerNodes) return;
                if (nodeType === boostNode && state.levelConfig && !state.levelConfig.allowBoostNodes) return;
                const available = state.dots.filter((dot) => dot.isNode && dot.type === nodeType.key && !dot.active);
                for (let i = 0; i < count && available.length; i++) {
                    const index = Math.floor(Math.random() * available.length);
                    const dot = available.splice(index, 1)[0];
                    dot.active = true;
                    dot.points = nodeType.points;
                }
            }

            function deployTool() {
                const now = performance.now();
                if (!useToolAuto(now, true)) {
                    showBanner('No Hat Ability Available');
                }
            }

            function completeLevel() {
                banner.textContent = 'Container Complete';
                banner.classList.add('visible');
                state.level += 1;
                state.chainIndex = 0;
                state.chainStreak = 0;
                state.chainStartTime = 0;
                state.lastChainTime = 0;
                state.hatCharges = { speed: 0, wall: 0, paint: 0, zap: 0 };
                state.equippedHats = [];
                state.speedBoostUntil = 0;
                state.wallPassUntil = 0;
                state.bugBoostUntil = 0;
                state.bugBoostFactor = 1;
                state.autoMistakeTargetKey = null;
                state.autoMistakeUntil = 0;
                state.bugThreatUntil = 0;
                state.inefficiencyCooldownUntil = 0;
                state.recoveryMode = false;
                state.savedChainSequence = null;
                state.savedChainSetIndex = 0;
                scheduleNextMistake(performance.now());

                const nextContainer = containerIndex + 1;
                const hasNextInRole = nextContainer <= roleConfig.levels.length;
                const nextRoleKey = hasNextInRole ? roleKey : roleConfig.nextRole;
                const nextRoleConfig = nextRoleKey ? roleConfigs[nextRoleKey] : null;
                const hasNext = hasNextInRole || !!nextRoleConfig;
                const nextContainerIndex = hasNextInRole ? nextContainer : 1;
                const nextLevel = hasNext
                    ? (hasNextInRole ? roleConfig.levels[nextContainerIndex - 1] : nextRoleConfig.levels[0])
                    : null;
                const nextLabel = hasNextInRole ? roleConfig.label : (nextRoleConfig ? nextRoleConfig.label : '');
                const message = hasNext
                    ? `${roleConfig.label} ${containerIndex} finished. It was destroyed to preserve resources. Spinning up ${nextLabel} ${nextContainerIndex}.`
                    : 'All slave and servant containers completed. Returning to the Container Lab overview.';
                const title = hasNext ? `${roleConfig.label} ${containerIndex} Complete` : 'All Containers Complete';
                const action = () => {
                    banner.classList.remove('visible');
                    if (hasNext) {
                        window.location.href = `playground.html?role=${nextRoleKey}&container=${nextContainerIndex}&level=${nextLevel}`;
                    } else {
                        window.location.href = 'index.html';
                    }
                };
                showModal(message, title, hasNext ? `Deploy ${nextLabel} ${nextContainerIndex}` : 'Return to lab', action);
            }

            function updateGhosts(delta) {
                if (state.freezeUntil > performance.now()) return;
                const frightened = state.frightenedUntil > performance.now();
                const bugBoost = state.bugBoostUntil > performance.now() ? state.bugBoostFactor : 1;
                state.ghosts.forEach((ghost) => {
                    const atCenter = Math.abs(ghost.c - Math.round(ghost.c)) < 0.05 && Math.abs(ghost.r - Math.round(ghost.r)) < 0.05;
                    if (atCenter) {
                        ghost.c = Math.round(ghost.c);
                        ghost.r = Math.round(ghost.r);
                        const target = getGhostTarget(ghost);
                        const options = getNeighbors(ghost.c, ghost.r);
                        let filtered = options;
                        if (options.length > 1) {
                            filtered = options.filter((opt) => !(opt.dirX === -ghost.dirX && opt.dirY === -ghost.dirY));
                        }
                        let best = filtered[0];
                        if (ghost.personality === 'random') {
                            best = filtered[Math.floor(Math.random() * filtered.length)];
                        } else {
                            best = chooseBestDirection(filtered, target, frightened);
                        }
                        if (best) {
                            ghost.dirX = best.dirX;
                            ghost.dirY = best.dirY;
                            ghost.heading = Math.atan2(best.dirY, best.dirX);
                        }
                    }

                    const speed = (frightened ? ghost.speed * 0.6 : ghost.speed) * bugBoost;
                    const nextC = ghost.c + ghost.dirX * speed * delta;
                    const nextR = ghost.r + ghost.dirY * speed * delta;
                    if (!isWall(Math.round(nextC), Math.round(nextR))) {
                        ghost.c = nextC;
                        ghost.r = nextR;
                    }
                });
            }

            function chooseBestDirection(options, target, frightened) {
                let best = options[0];
                let bestScore = frightened ? -Infinity : Infinity;
                options.forEach((opt) => {
                    const dist = Math.abs(target.c - opt.c) + Math.abs(target.r - opt.r);
                    if (frightened) {
                        if (dist > bestScore) {
                            bestScore = dist;
                            best = opt;
                        }
                    } else if (dist < bestScore) {
                        bestScore = dist;
                        best = opt;
                    }
                });
                return best;
            }

            function getGhostTarget(ghost) {
                if (state.frightenedUntil > performance.now()) {
                    return { c: ghost.c, r: ghost.r };
                }
                if (state.mode === 'scatter') {
                    const corners = [
                        { c: 1, r: 1 },
                        { c: state.cols - 2, r: 1 },
                        { c: 1, r: state.rows - 2 },
                        { c: state.cols - 2, r: state.rows - 2 }
                    ];
                    return corners[ghostConfigs.findIndex((g) => g.id === ghost.id)] || corners[0];
                }
                if (ghost.personality === 'chase') {
                    return { c: Math.round(state.player.c), r: Math.round(state.player.r) };
                }
                if (ghost.personality === 'ambush') {
                    return {
                        c: Math.round(state.player.c + state.player.dirX * 4),
                        r: Math.round(state.player.r + state.player.dirY * 4)
                    };
                }
                if (ghost.personality === 'guard') {
                    return {
                        c: Math.round(state.player.c + (state.player.c - state.cols / 2) * 0.5),
                        r: Math.round(state.player.r + (state.player.r - state.rows / 2) * 0.5)
                    };
                }
                return { c: Math.round(state.player.c), r: Math.round(state.player.r) };
            }

            function checkCollisions() {
                const now = performance.now();
                const frightened = state.frightenedUntil > now;
                const bugThreatActive = state.bugThreatUntil > now;
                if (state.safeMode || (state.levelConfig && state.levelConfig.bugsEnabled === false)) {
                    return;
                }
                state.ghosts.forEach((ghost) => {
                    const dist = Math.hypot(state.player.c - ghost.c, state.player.r - ghost.r);
                    if (dist < 0.4) {
                        if (frightened) {
                            state.score += 200;
                            showBanner('Bug Squashed +200');
                            playEvent('chain');
                            setNarration('Bug squashed. Tool suppression is active.');
                            const spawn = findOpenCell(Math.floor(state.cols / 2), Math.floor(state.rows / 2));
                            ghost.c = spawn.c;
                            ghost.r = spawn.r;
                            ghost.dirX = 0;
                            ghost.dirY = -1;
                            ghost.heading = -Math.PI / 2;
                        } else if (bugThreatActive) {
                            playEvent('bug');
                            state.score = Math.max(0, state.score - 20);
                            showBanner('Bug Encountered - Recovery Mode');
                            setNarration('Bug triggered. Agent is recovering and resuming the chain.');
                            state.freezeUntil = now + 800;
                            resetPositions();
                            state.bugThreatUntil = now + 2000;
                            enterRecoveryMode();
                        }
                    }
                });
            }

            function drawBackground() {
                const gradient = ctx.createLinearGradient(0, 0, 0, state.height);
                gradient.addColorStop(0, '#1f2a36');
                gradient.addColorStop(1, '#0f151e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, state.width, state.height);
            }

            function drawWalls() {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.16)';
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.5)';
                ctx.lineWidth = 2;
                for (let r = 0; r < state.rows; r++) {
                    for (let c = 0; c < state.cols; c++) {
                        if (!isWall(c, r)) continue;
                        const x = state.levelRect.x + c * state.cellSize;
                        const y = state.levelRect.y + r * state.cellSize;
                        ctx.fillRect(x, y, state.cellSize, state.cellSize);
                        ctx.strokeRect(x + 1, y + 1, state.cellSize - 2, state.cellSize - 2);
                    }
                }
            }

            function drawDots(time) {
                state.dots.forEach((dot) => {
                    if (!dot.active) return;
                    const center = cellCenter(dot.c, dot.r);
                    const pulse = 0.6 + Math.sin(time * 4) * 0.2;
                    const radius = dot.type === powerNode.key ? state.cellSize * 0.22 * pulse : state.cellSize * 0.1 * pulse;
                    let color = powerNode.color;
                    if (dot.type === boostNode.key) {
                        color = boostNode.color;
                    } else if (dot.type !== powerNode.key) {
                        const match = chainSequence.find((entry) => entry.key === dot.type);
                        color = match ? match.color : '#ecf0f1';
                    }
                    ctx.fillStyle = color;
                    if (dot.type === boostNode.key) {
                        ctx.save();
                        ctx.translate(center.x, center.y);
                        ctx.rotate(Math.PI / 4);
                        ctx.fillRect(-radius, -radius, radius * 2, radius * 2);
                        ctx.restore();
                        ctx.strokeStyle = 'rgba(236, 240, 241, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(center.x - radius * 1.1, center.y - radius * 1.1, radius * 2.2, radius * 2.2);
                    } else {
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        if (dot.type === 'black') {
                            ctx.strokeStyle = 'rgba(236, 240, 241, 0.6)';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                });
            }

            function drawRoundedRect(x, y, w, h, r) {
                const radius = Math.min(r, w / 2, h / 2);
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + w - radius, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
                ctx.lineTo(x + w, y + h - radius);
                ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
                ctx.lineTo(x + radius, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            function drawRobot(time) {
                const center = cellCenter(state.player.c, state.player.r);
                const size = state.cellSize * 0.75;
                const mouthPulse = 0.35 + Math.abs(Math.sin(time * 6)) * 0.35;
                const mouthHeight = size * (0.14 + mouthPulse * 0.15);
                const zapActive = state.zapFlashUntil > performance.now();
                ctx.save();
                ctx.translate(center.x, center.y);
                ctx.rotate(state.player.heading || 0);

                ctx.fillStyle = '#dfe6e9';
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 2;
                drawRoundedRect(-size / 2, -size / 2, size, size * 0.85, size * 0.18);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#2f3640';
                ctx.fillRect(-size * 0.35, size * 0.05, size * 0.7, mouthHeight);

                ctx.fillStyle = '#f5f6fa';
                const toothCount = 5;
                const toothWidth = (size * 0.6) / toothCount;
                for (let i = 0; i < toothCount; i++) {
                    const tx = -size * 0.3 + i * toothWidth;
                    ctx.fillRect(tx, size * 0.05, toothWidth * 0.6, mouthHeight * 0.4);
                    ctx.fillRect(tx, size * 0.05 + mouthHeight * 0.6, toothWidth * 0.6, mouthHeight * 0.35);
                }

                ctx.fillStyle = '#2d3436';
                ctx.beginPath();
                ctx.arc(-size * 0.18, -size * 0.08, size * 0.08, 0, Math.PI * 2);
                ctx.arc(size * 0.18, -size * 0.08, size * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = zapActive ? '#ff3b30' : '#00cec9';
                ctx.beginPath();
                ctx.arc(-size * 0.18, -size * 0.08, size * 0.04, 0, Math.PI * 2);
                ctx.arc(size * 0.18, -size * 0.08, size * 0.04, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawGhosts(time) {
                const frightened = state.frightenedUntil > performance.now();
                state.ghosts.forEach((ghost) => {
                    const center = cellCenter(ghost.c, ghost.r);
                    const size = state.cellSize * 0.7;
                    const wave = Math.sin(time * 4) * 2;
                    ctx.save();
                    ctx.translate(center.x, center.y);
                    ctx.fillStyle = frightened ? '#5dade2' : ghost.color;
                    ctx.beginPath();
                    ctx.moveTo(-size / 2, size / 2);
                    ctx.lineTo(-size / 2, -size / 4);
                    ctx.quadraticCurveTo(0, -size / 2, size / 2, -size / 4);
                    ctx.lineTo(size / 2, size / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ecf0f1';
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, -size * 0.1 + wave * 0.1, size * 0.12, 0, Math.PI * 2);
                    ctx.arc(size * 0.2, -size * 0.1 + wave * 0.1, size * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#1b1f24';
                    ctx.beginPath();
                    ctx.arc(-size * 0.2, -size * 0.1 + wave * 0.1, size * 0.05, 0, Math.PI * 2);
                    ctx.arc(size * 0.2, -size * 0.1 + wave * 0.1, size * 0.05, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }

            function drawFrame() {
                ctx.strokeStyle = 'rgba(148, 163, 184, 0.35)';
                ctx.lineWidth = 3;
                ctx.strokeRect(state.levelRect.x - 4, state.levelRect.y - 4, state.levelRect.w + 8, state.levelRect.h + 8);
            }

            function render(time) {
                drawBackground();
                drawWalls();
                drawDots(time);
                drawGhosts(time);
                drawRobot(time);
                drawFrame();
            }

            function update(delta) {
                if (state.paused) return;
                if (state.freezeUntil > performance.now()) return;
                updateMode(delta);
                updatePlayer(delta);
                updateGhosts(delta);
                checkCollisions();
                updateHud();
                updateDebug(performance.now());
                updateNarration(delta, performance.now());
            }

            function loop(timestamp) {
                if (!state.lastTime) state.lastTime = timestamp;
                const delta = Math.min(0.05, (timestamp - state.lastTime) / 1000);
                state.lastTime = timestamp;
                update(delta);
                render(timestamp / 1000);
                requestAnimationFrame(loop);
            }

            function handleInteraction() {
                if (sound.enabled && !sound.ctx) {
                    unlockAudio();
                }
            }

            document.addEventListener('keydown', (event) => {
                handleInteraction();
                if (event.key === 'Escape') {
                    state.paused = !state.paused;
                    return;
                }
                if (event.code === 'Space') {
                    if (state.playerMode) {
                        state.eatHeld = true;
                    }
                    return;
                }
                if (event.key.toLowerCase() === 'm') {
                    sound.enabled = !sound.enabled;
                    showBanner(`Sound ${sound.enabled ? 'On' : 'Off'}`);
                    if (sound.enabled && !sound.ctx) {
                        unlockAudio();
                    }
                    return;
                }
                if (event.key.toLowerCase() === 'p') {
                    state.playerMode = !state.playerMode;
                    state.autopilot = !state.playerMode;
                    state.eatHeld = false;
                    showBanner(state.playerMode ? 'Player Mode Enabled' : 'Demo Mode Enabled');
                    setNarration(state.playerMode
                        ? 'Player mode: use arrows and hold Space to eat.'
                        : 'Demo mode: autoplay resumes to explain the system.');
                    updateHud();
                    return;
                }
                if (event.key.toLowerCase() === 'a' && state.playerMode) {
                    state.autopilot = !state.autopilot;
                    updateHud();
                    return;
                }
                if (event.key.toLowerCase() === 't') {
                    deployTool();
                    return;
                }
                if (event.key.toLowerCase() === 'b') {
                    state.safeMode = !state.safeMode;
                    if (state.safeMode) {
                        state.bugThreatUntil = 0;
                    }
                    showBanner(`Safe Mode ${state.safeMode ? 'On' : 'Off'}`);
                    updateHud();
                    return;
                }
                if (event.key.toLowerCase() === 'r') {
                    buildLevel();
                    return;
                }

                const keyName = event.key.toLowerCase();
                if (!state.playerMode) {
                    return;
                }
                if (['arrowup', 'w'].includes(keyName)) {
                    state.autopilot = false;
                    state.player.dirX = 0;
                    state.player.dirY = -1;
                    state.player.heading = -Math.PI / 2;
                }
                if (['arrowdown', 's'].includes(keyName)) {
                    state.autopilot = false;
                    state.player.dirX = 0;
                    state.player.dirY = 1;
                    state.player.heading = Math.PI / 2;
                }
                if (['arrowleft'].includes(keyName)) {
                    state.autopilot = false;
                    state.player.dirX = -1;
                    state.player.dirY = 0;
                    state.player.heading = Math.PI;
                }
                if (['arrowright', 'd'].includes(keyName)) {
                    state.autopilot = false;
                    state.player.dirX = 1;
                    state.player.dirY = 0;
                    state.player.heading = 0;
                }
                updateHud();
            });

            document.addEventListener('keyup', (event) => {
                if (event.code === 'Space') {
                    state.eatHeld = false;
                }
            });

            if (tutorialOk) {
                tutorialOk.addEventListener('click', () => {
                    dismissTutorial();
                });
            }

            if (hatSelectConfirm) {
                hatSelectConfirm.addEventListener('click', () => {
                    applyHatSelection();
                });
            }

            document.addEventListener('keydown', (event) => {
                if (state.tutorialActive && event.key === 'Enter') {
                    dismissTutorial();
                }
                if (hatSelectOverlay && hatSelectOverlay.classList.contains('visible') && event.key === 'Enter') {
                    applyHatSelection();
                }
            });

            document.addEventListener('pointerdown', handleInteraction, { passive: true });
            window.addEventListener('resize', resize);
            applyLevelConfig();
            initChainRow();
            resize();
            updateHud();
            if (state.narrationScript && state.narrationScript.length) {
                setNarration(state.narrationScript[0], 4000);
            }
            window.__labState = state;
            if (debugPanel) {
                debugPanel.style.display = debugEnabled ? 'block' : 'none';
                updateDebug(performance.now());
            }
            requestAnimationFrame(loop);
        })();
    </script>
</body>
</html>
