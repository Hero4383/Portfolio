<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thin Render RTC Viewer</title>
    <style>
        :root {
            --green: #00ff41;
            --bg: #040a06;
            --panel: rgba(0, 20, 0, 0.8);
            --panel-border: rgba(0, 255, 65, 0.25);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Courier New', monospace;
            color: var(--green);
            background: radial-gradient(circle at top, #0a1a10 0%, #040a06 50%, #020503 100%);
            min-height: 100vh;
        }

        header {
            border-bottom: 1px solid var(--panel-border);
            background: rgba(0, 10, 0, 0.85);
            padding: 16px 24px;
        }

        header h1 {
            margin: 0;
            font-size: 20px;
            letter-spacing: 0.5px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        .layout {
            display: grid;
            grid-template-columns: minmax(260px, 320px) 1fr;
            gap: 20px;
        }

        .stream-stack {
            display: grid;
            gap: 16px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }

        .panel h2 {
            margin: 0 0 12px;
            font-size: 16px;
        }

        .panel p {
            margin: 8px 0 16px;
            font-size: 12px;
            line-height: 1.5;
            color: rgba(0, 255, 65, 0.8);
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            background: rgba(0, 0, 0, 0.4);
            font-size: 12px;
            margin-bottom: 12px;
        }

        button {
            width: 100%;
            background: rgba(0, 255, 65, 0.15);
            border: 1px solid var(--green);
            color: var(--green);
            padding: 10px 14px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: rgba(0, 255, 65, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            margin-bottom: 12px;
        }

        .toggle input {
            accent-color: var(--green);
        }

        .file-input {
            font-size: 12px;
            margin-bottom: 8px;
        }

        .stage {
            position: relative;
            background: #020503;
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            overflow: hidden;
            height: min(70vh, 640px);
            min-height: 360px;
        }

        .stream-stack.docked .stage {
            height: min(45vh, 420px);
            min-height: 300px;
        }

        .dock {
            display: none;
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.35);
            height: min(45vh, 480px);
            min-height: 260px;
        }

        .dock.visible {
            display: block;
        }

        .dock iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        #backgroundVideo,
        #remoteVideo {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #bgPlaceholder {
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, #0b1f14, #0b3324, #0b1f14);
            background-size: 300% 300%;
            animation: drift 12s ease infinite;
        }

        #remoteVideo {
            width: 260px;
            height: 180px;
            right: 18px;
            bottom: 18px;
            left: auto;
            top: auto;
            border: 1px solid var(--green);
            border-radius: 10px;
            object-fit: contain;
            background: rgba(0, 0, 0, 0.6);
        }

        .stage.full #remoteVideo {
            inset: 0;
            width: 100%;
            height: 100%;
            border-radius: 0;
        }

        .watermark-label {
            position: absolute;
            right: 24px;
            bottom: 210px;
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--panel-border);
        }

        .stage.full .watermark-label {
            display: none;
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            text-align: center;
            font-size: 13px;
            color: rgba(0, 255, 65, 0.85);
            background: rgba(0, 0, 0, 0.35);
            padding: 20px;
        }

        @keyframes drift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Thin Render RTC Viewer</h1>
    </header>

    <div class="container">
        <div class="layout">
            <div class="panel">
                <h2>Stream Controls</h2>
                <p>Open the 3D Model Viewer, load a model + textures, then click "Start Stream". This page will auto-connect and display the live stream.</p>
                <div id="status" class="status">Status: waiting for offer</div>
                <button id="requestBtn">Request Stream</button>
                <button id="disconnectBtn" disabled>Disconnect</button>

                <div class="toggle">
                    <input type="checkbox" id="watermarkToggle" checked>
                    <label for="watermarkToggle">Watermark mode (overlay)</label>
                </div>

                <div class="toggle">
                    <input type="checkbox" id="dockToggle">
                    <label for="dockToggle">Dock 3D Viewer (single-tab mode)</label>
                </div>

                <div class="file-input">Optional background video:</div>
                <input type="file" id="bgVideoInput" accept="video/*">
                <p>Tip: browsers throttle hidden tabs. Docking keeps the 3D viewer active for a smooth stream.</p>
            </div>

            <div class="stream-stack" id="streamStack">
                <div class="stage" id="stage">
                    <div id="bgPlaceholder"></div>
                    <video id="backgroundVideo" autoplay muted loop playsinline></video>
                    <video id="remoteVideo" autoplay muted playsinline></video>
                    <div class="watermark-label">3D Model Stream</div>
                    <div id="noStream" class="overlay">Waiting for stream...</div>
                </div>
                <div class="dock" id="dockPane">
                    <iframe id="dockFrame" title="Docked 3D Viewer" src="../3d-model-viewer/index.html?dock=1"></iframe>
                </div>
            </div>
        </div>
    </div>

    <script>
        const channelName = 'portfolio-rtc-demo-v2';
        const channel = ('BroadcastChannel' in window) ? new BroadcastChannel(channelName) : null;

        const statusEl = document.getElementById('status');
        const stageEl = document.getElementById('stage');
        const remoteVideo = document.getElementById('remoteVideo');
        const backgroundVideo = document.getElementById('backgroundVideo');
        const bgPlaceholder = document.getElementById('bgPlaceholder');
        const noStream = document.getElementById('noStream');
        const requestBtn = document.getElementById('requestBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const watermarkToggle = document.getElementById('watermarkToggle');
        const bgVideoInput = document.getElementById('bgVideoInput');
        const dockToggle = document.getElementById('dockToggle');
        const dockPane = document.getElementById('dockPane');
        const streamStack = document.getElementById('streamStack');

        let pc = null;
        let currentSessionId = null;

        function setStatus(message) {
            statusEl.textContent = `Status: ${message}`;
        }

        function sendChannelMessage(payload) {
            if (!channel) return;
            try {
                channel.postMessage(JSON.stringify(payload));
            } catch (error) {
                console.warn('RTC channel send failed', error);
            }
        }

        function readChannelMessage(event) {
            const data = event.data;
            if (typeof data === 'string') {
                try {
                    return JSON.parse(data);
                } catch (error) {
                    return null;
                }
            }
            return data;
        }

        function setConnected(connected) {
            disconnectBtn.disabled = !connected;
        }

        function showStream(active) {
            noStream.style.display = active ? 'none' : 'grid';
        }

        function closePeer(reason) {
            if (channel && currentSessionId) {
                sendChannelMessage({ type: 'stop', role: 'rtc', sessionId: currentSessionId });
            }
            if (pc) {
                pc.ontrack = null;
                pc.onicecandidate = null;
                pc.onconnectionstatechange = null;
                pc.oniceconnectionstatechange = null;
                pc.close();
                pc = null;
            }
            currentSessionId = null;
            remoteVideo.srcObject = null;
            showStream(false);
            setConnected(false);
            setStatus(reason || 'disconnected');
        }

        function ensurePeer(sessionId) {
            if (pc) {
                closePeer('reconnecting');
            }
            currentSessionId = sessionId;
            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.ontrack = (event) => {
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.play().catch(() => {});
                    showStream(true);
                }
            };

            pc.onicecandidate = (event) => {
                if (event.candidate && channel) {
                    const payload = event.candidate.toJSON ? event.candidate.toJSON() : {
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        usernameFragment: event.candidate.usernameFragment
                    };
                    sendChannelMessage({
                        type: 'ice',
                        role: 'rtc',
                        sessionId: currentSessionId,
                        candidate: payload
                    });
                }
            };

            pc.onconnectionstatechange = () => {
                if (!pc) return;
                const state = pc.connectionState;
                setStatus(state);
                setConnected(state === 'connected');
                if (state === 'failed' || state === 'closed' || state === 'disconnected') {
                    showStream(false);
                }
            };

            pc.oniceconnectionstatechange = () => {
                if (!pc) return;
                if (pc.iceConnectionState === 'connected') {
                    setStatus('connected');
                    setConnected(true);
                }
            };
        }

        async function handleOffer(msg) {
            if (!msg || !msg.sdp || !msg.sessionId) return;
            ensurePeer(msg.sessionId);
            try {
                await pc.setRemoteDescription({ type: 'offer', sdp: msg.sdp });
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                sendChannelMessage({
                    type: 'answer',
                    role: 'rtc',
                    sessionId: currentSessionId,
                    sdp: answer.sdp
                });
                setStatus('answer sent');
            } catch (error) {
                setStatus('offer failed');
            }
        }

        if (channel) {
            channel.onmessage = (event) => {
                const msg = readChannelMessage(event) || {};
                if (msg.role === 'rtc') return;
                if (msg.type === 'offer') {
                    handleOffer(msg);
                } else if (msg.type === 'ice' && msg.sessionId === currentSessionId && msg.candidate) {
                    if (pc) {
                        pc.addIceCandidate(new RTCIceCandidate(msg.candidate)).catch(() => {});
                    }
                } else if (msg.type === 'stop' && msg.sessionId === currentSessionId) {
                    closePeer('stopped by sender');
                }
            };
        } else {
            setStatus('BroadcastChannel unavailable');
            requestBtn.disabled = true;
        }

        requestBtn.addEventListener('click', () => {
            if (!channel) return;
            setStatus('requesting stream');
            sendChannelMessage({ type: 'request-offer', role: 'rtc' });
        });

        disconnectBtn.addEventListener('click', () => {
            closePeer('disconnected');
        });

        watermarkToggle.addEventListener('change', () => {
            if (watermarkToggle.checked) {
                stageEl.classList.remove('full');
            } else {
                stageEl.classList.add('full');
            }
        });

        dockToggle.addEventListener('change', () => {
            if (dockToggle.checked) {
                dockPane.classList.add('visible');
                streamStack.classList.add('docked');
            } else {
                dockPane.classList.remove('visible');
                streamStack.classList.remove('docked');
            }
        });

        bgVideoInput.addEventListener('change', (event) => {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            backgroundVideo.src = url;
            backgroundVideo.play().catch(() => {});
            bgPlaceholder.style.display = 'none';
        });

        remoteVideo.addEventListener('loadedmetadata', () => {
            remoteVideo.play().catch(() => {});
        });

        window.addEventListener('beforeunload', () => {
            closePeer('closing');
        });
    </script>
</body>
</html>
