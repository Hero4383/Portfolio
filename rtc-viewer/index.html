<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thin Render RTC Viewer</title>
    <style>
        :root {
            --green: #00ff41;
            --bg: #040a06;
            --panel: rgba(0, 20, 0, 0.8);
            --panel-border: rgba(0, 255, 65, 0.25);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Courier New', monospace;
            color: var(--green);
            background: radial-gradient(circle at top, #0a1a10 0%, #040a06 50%, #020503 100%);
            min-height: 100vh;
        }

        header {
            border-bottom: 1px solid var(--panel-border);
            background: rgba(0, 10, 0, 0.85);
            padding: 16px 24px;
        }

        header h1 {
            margin: 0;
            font-size: 20px;
            letter-spacing: 0.5px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        .layout {
            display: grid;
            grid-template-columns: minmax(260px, 320px) 1fr;
            gap: 20px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }

        .panel h2 {
            margin: 0 0 12px;
            font-size: 16px;
        }

        .panel p {
            margin: 8px 0 16px;
            font-size: 12px;
            line-height: 1.5;
            color: rgba(0, 255, 65, 0.8);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            background: rgba(0, 0, 0, 0.4);
            font-size: 12px;
            margin-bottom: 12px;
        }

        button {
            width: 100%;
            background: rgba(0, 255, 65, 0.15);
            border: 1px solid var(--green);
            color: var(--green);
            padding: 10px 14px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: rgba(0, 255, 65, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            margin-bottom: 12px;
        }

        .toggle input {
            accent-color: var(--green);
        }

        .file-input {
            font-size: 12px;
            margin-bottom: 8px;
        }

        .stage {
            position: relative;
            background: #020503;
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            overflow: hidden;
            height: min(70vh, 640px);
            min-height: 360px;
        }

        #backgroundVideo,
        #remoteVideo {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #bgPlaceholder {
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, #0b1f14, #0b3324, #0b1f14);
            background-size: 300% 300%;
            animation: drift 12s ease infinite;
        }

        #streamOverlay {
            position: absolute;
            width: 260px;
            height: 180px;
            right: 18px;
            bottom: 18px;
            left: auto;
            top: auto;
            cursor: grab;
            touch-action: none;
        }

        #streamOverlay.dragging {
            cursor: grabbing;
        }

        #remoteVideo {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            object-fit: contain;
            background: transparent;
            pointer-events: none;
            display: none;
        }

        #streamCanvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            display: block;
            pointer-events: none;
        }

        .stream-label {
            position: absolute;
            right: 0;
            top: -18px;
            font-size: 11px;
            color: rgba(0, 255, 65, 0.9);
            text-shadow: 0 0 6px rgba(0, 255, 65, 0.5);
            pointer-events: none;
        }

        .resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            right: 0;
            bottom: 0;
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 65, 0.4);
            background: rgba(0, 255, 65, 0.15);
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        #streamOverlay:hover .resize-handle {
            opacity: 1;
        }

        #streamOverlay.resize-active {
            outline: 1px dashed rgba(0, 255, 65, 0.5);
            outline-offset: 6px;
        }

        #streamOverlay.outline-hidden,
        #streamOverlay.outline-hidden.resize-active {
            outline: none;
        }

        .stream-outline-visible {
            outline: 1px dashed rgba(180, 0, 255, 0.75);
            outline-offset: 2px;
        }

        .stage.full #streamOverlay {
            inset: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        .stage.full #remoteVideo {
            border-radius: 0;
        }

        .stage.full .resize-handle,
        .stage.full .stream-label {
            display: none;
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            text-align: center;
            font-size: 13px;
            color: rgba(0, 255, 65, 0.85);
            background: rgba(0, 0, 0, 0.35);
            padding: 20px;
        }

        @keyframes drift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @media (max-width: 900px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Thin Render RTC Viewer</h1>
    </header>

    <div class="container">
        <div class="layout">
            <div class="panel">
                <h2>Stream Controls</h2>
                <p>Open the 3D Model Viewer, load a model + textures, then click "Start Stream". This page will auto-connect and display the live stream.</p>
                <div id="status" class="status">Status: waiting for offer</div>
                <button id="requestBtn">Request Stream</button>
                <button id="disconnectBtn" disabled>Disconnect</button>

                <div class="control-group">
                    <div class="toggle">
                        <input type="checkbox" id="watermarkToggle" checked>
                        <label for="watermarkToggle">Watermark mode (overlay)</label>
                    </div>
                </div>

                <div class="file-input">Optional background video:</div>
                <input type="file" id="bgVideoInput" accept="video/*">
                <p>Tip: leave the 3D viewer open while exploring this view to simulate a remote thin-client stream.</p>
            </div>

            <div class="stage" id="stage">
                <div id="bgPlaceholder"></div>
                <video id="backgroundVideo" autoplay muted loop playsinline></video>
                <div id="streamOverlay">
                    <video id="remoteVideo" autoplay muted playsinline></video>
                    <canvas id="streamCanvas"></canvas>
                    <div class="stream-label">3D Model Stream</div>
                    <div id="resizeHandle" class="resize-handle" title="Toggle resize mode"></div>
                </div>
                <div id="noStream" class="overlay">Waiting for stream...</div>
            </div>
        </div>
    </div>

    <script>
        const channelName = 'portfolio-rtc-demo-v2';
        const channel = ('BroadcastChannel' in window) ? new BroadcastChannel(channelName) : null;

        const statusEl = document.getElementById('status');
        const stageEl = document.getElementById('stage');
        const remoteVideo = document.getElementById('remoteVideo');
        const streamCanvas = document.getElementById('streamCanvas');
        const streamCtx = streamCanvas.getContext('2d', { willReadFrequently: true });
        const backgroundVideo = document.getElementById('backgroundVideo');
        const bgPlaceholder = document.getElementById('bgPlaceholder');
        const noStream = document.getElementById('noStream');
        const requestBtn = document.getElementById('requestBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const watermarkToggle = document.getElementById('watermarkToggle');
        const bgVideoInput = document.getElementById('bgVideoInput');
        const streamOverlay = document.getElementById('streamOverlay');
        const resizeHandle = document.getElementById('resizeHandle');

        let pc = null;
        let currentSessionId = null;
        let tickTimer = null;
        const tickIntervalMs = 1000 / 30;
        let dragState = null;
        let resizeState = null;
        const minOverlaySize = { width: 160, height: 120 };
        const overlayMargin = 180;
        let resizeEnabled = false;
        let frameLoopActive = false;
        let contentBounds = null;
        const keyColor = { r: 255, g: 0, b: 255 };
        const keyThreshold = 28;
        const keySoftness = 40;
        const despillStrength = 0.85;
        const workCanvas = document.createElement('canvas');
        const workCtx = workCanvas.getContext('2d', { willReadFrequently: true });
        let outlineHideTimer = null;
        const outlineDelayMs = 1800;

        function setStatus(message) {
            statusEl.textContent = `Status: ${message}`;
        }

        function sendChannelMessage(payload) {
            if (!channel) return;
            try {
                channel.postMessage(JSON.stringify(payload));
            } catch (error) {
                console.warn('RTC channel send failed', error);
            }
        }

        function readChannelMessage(event) {
            const data = event.data;
            if (typeof data === 'string') {
                try {
                    return JSON.parse(data);
                } catch (error) {
                    return null;
                }
            }
            return data;
        }

        function startTickLoop() {
            if (tickTimer || !channel || !currentSessionId) return;
            tickTimer = setInterval(() => {
                if (!channel || !currentSessionId) return;
                sendChannelMessage({ type: 'tick', role: 'rtc', sessionId: currentSessionId });
            }, tickIntervalMs);
        }

        function stopTickLoop() {
            if (tickTimer) {
                clearInterval(tickTimer);
                tickTimer = null;
            }
        }

        function setConnected(connected) {
            disconnectBtn.disabled = !connected;
        }

        function showStream(active) {
            noStream.style.display = active ? 'none' : 'grid';
        }

        function setOutlineVisible(visible) {
            streamOverlay.classList.toggle('outline-hidden', !visible);
            streamOverlay.classList.toggle('stream-outline-visible', visible);
        }

        function showOutlineTemporarily() {
            setOutlineVisible(true);
            if (outlineHideTimer) {
                clearTimeout(outlineHideTimer);
            }
            outlineHideTimer = setTimeout(() => {
                if (resizeEnabled || dragState || resizeState) return;
                setOutlineVisible(false);
            }, outlineDelayMs);
        }

        function getContentBoundsInOverlay() {
            if (!contentBounds || !streamCanvas.width || !streamCanvas.height) return null;
            const scaleX = streamOverlay.clientWidth / streamCanvas.width;
            const scaleY = streamOverlay.clientHeight / streamCanvas.height;
            return {
                left: contentBounds.left * scaleX,
                top: contentBounds.top * scaleY,
                right: contentBounds.right * scaleX,
                bottom: contentBounds.bottom * scaleY
            };
        }

        function getOverlayBounds() {
            const stageRect = stageEl.getBoundingClientRect();
            const overlayRect = streamOverlay.getBoundingClientRect();
            return { stageRect, overlayRect };
        }

        function setOverlayPosition(left, top) {
            const { stageRect, overlayRect } = getOverlayBounds();
            const content = getContentBoundsInOverlay();
            let minLeft = -overlayMargin;
            let maxLeft = stageRect.width - overlayRect.width + overlayMargin;
            let minTop = -overlayMargin;
            let maxTop = stageRect.height - overlayRect.height + overlayMargin;

            if (content) {
                minLeft = -content.left;
                maxLeft = stageRect.width - content.right;
                minTop = -content.top;
                maxTop = stageRect.height - content.bottom;
            }
            const clampedLeft = Math.min(Math.max(left, minLeft), maxLeft);
            const clampedTop = Math.min(Math.max(top, minTop), maxTop);
            streamOverlay.style.left = `${clampedLeft}px`;
            streamOverlay.style.top = `${clampedTop}px`;
            streamOverlay.style.right = 'auto';
            streamOverlay.style.bottom = 'auto';
        }

        function beginDrag(event) {
            if (stageEl.classList.contains('full')) return;
            if (event.button !== 0) return;
            const { stageRect, overlayRect } = getOverlayBounds();
            dragState = {
                startX: event.clientX,
                startY: event.clientY,
                baseLeft: overlayRect.left - stageRect.left,
                baseTop: overlayRect.top - stageRect.top
            };
            streamOverlay.setPointerCapture(event.pointerId);
            streamOverlay.classList.add('dragging');
        }

        function onDrag(event) {
            if (!dragState) return;
            const deltaX = event.clientX - dragState.startX;
            const deltaY = event.clientY - dragState.startY;
            setOverlayPosition(dragState.baseLeft + deltaX, dragState.baseTop + deltaY);
        }

        function endDrag(event) {
            if (!dragState) return;
            streamOverlay.releasePointerCapture(event.pointerId);
            streamOverlay.classList.remove('dragging');
            dragState = null;
        }

        function beginResize(event) {
            if (!resizeEnabled) return;
            if (stageEl.classList.contains('full')) return;
            event.stopPropagation();
            const { stageRect, overlayRect } = getOverlayBounds();
            resizeState = {
                startX: event.clientX,
                startY: event.clientY,
                baseWidth: overlayRect.width,
                baseHeight: overlayRect.height,
                maxWidth: stageRect.width + overlayMargin * 2,
                maxHeight: stageRect.height + overlayMargin * 2
            };
            resizeHandle.setPointerCapture(event.pointerId);
        }

        function onResize(event) {
            if (!resizeState) return;
            const deltaX = event.clientX - resizeState.startX;
            const deltaY = event.clientY - resizeState.startY;
            const nextWidth = Math.min(
                Math.max(resizeState.baseWidth + deltaX, minOverlaySize.width),
                resizeState.maxWidth
            );
            const nextHeight = Math.min(
                Math.max(resizeState.baseHeight + deltaY, minOverlaySize.height),
                resizeState.maxHeight
            );
            streamOverlay.style.width = `${nextWidth}px`;
            streamOverlay.style.height = `${nextHeight}px`;
            const { stageRect, overlayRect } = getOverlayBounds();
            const left = overlayRect.left - stageRect.left;
            const top = overlayRect.top - stageRect.top;
            setOverlayPosition(left, top);
        }

        function endResize(event) {
            if (!resizeState) return;
            resizeHandle.releasePointerCapture(event.pointerId);
            resizeState = null;
        }

        function closePeer(reason) {
            if (channel && currentSessionId) {
                sendChannelMessage({ type: 'stop', role: 'rtc', sessionId: currentSessionId });
            }
            stopTickLoop();
            stopFrameLoop();
            if (pc) {
                pc.ontrack = null;
                pc.onicecandidate = null;
                pc.onconnectionstatechange = null;
                pc.oniceconnectionstatechange = null;
                pc.close();
                pc = null;
            }
            currentSessionId = null;
            remoteVideo.srcObject = null;
            showStream(false);
            setConnected(false);
            setStatus(reason || 'disconnected');
        }

        function ensurePeer(sessionId) {
            if (pc) {
                closePeer('reconnecting');
            }
            currentSessionId = sessionId;
            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.ontrack = (event) => {
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.play().catch(() => {});
                    showStream(true);
                    startFrameLoop();
                }
            };

            pc.onicecandidate = (event) => {
                if (event.candidate && channel) {
                    const payload = event.candidate.toJSON ? event.candidate.toJSON() : {
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        usernameFragment: event.candidate.usernameFragment
                    };
                    sendChannelMessage({
                        type: 'ice',
                        role: 'rtc',
                        sessionId: currentSessionId,
                        candidate: payload
                    });
                }
            };

            pc.onconnectionstatechange = () => {
                if (!pc) return;
                const state = pc.connectionState;
                setStatus(state);
                setConnected(state === 'connected');
                if (state === 'failed' || state === 'closed' || state === 'disconnected') {
                    showStream(false);
                    stopTickLoop();
                    stopFrameLoop();
                }
            };

            pc.oniceconnectionstatechange = () => {
                if (!pc) return;
                if (pc.iceConnectionState === 'connected') {
                    setStatus('connected');
                    setConnected(true);
                }
            };
        }

        async function handleOffer(msg) {
            if (!msg || !msg.sdp || !msg.sessionId) return;
            ensurePeer(msg.sessionId);
            try {
                await pc.setRemoteDescription({ type: 'offer', sdp: msg.sdp });
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                sendChannelMessage({
                    type: 'answer',
                    role: 'rtc',
                    sessionId: currentSessionId,
                    sdp: answer.sdp
                });
                startTickLoop();
                setStatus('answer sent');
            } catch (error) {
                setStatus('offer failed');
            }
        }

        function processFrame() {
            if (!frameLoopActive) return;
            if (!remoteVideo.videoWidth || !remoteVideo.videoHeight) {
                scheduleFrame();
                return;
            }

            const w = remoteVideo.videoWidth;
            const h = remoteVideo.videoHeight;
            if (workCanvas.width != w || workCanvas.height != h) {
                workCanvas.width = w;
                workCanvas.height = h;
            }
            if (streamCanvas.width != w || streamCanvas.height != h) {
                streamCanvas.width = w;
                streamCanvas.height = h;
            }

            workCtx.drawImage(remoteVideo, 0, 0, w, h);
            const frame = workCtx.getImageData(0, 0, w, h);
            const data = frame.data;
            let minX = w;
            let minY = h;
            let maxX = 0;
            let maxY = 0;
            let hasContent = false;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const dr = r - keyColor.r;
                const dg = g - keyColor.g;
                const db = b - keyColor.b;
                const dist = Math.max(Math.abs(dr), Math.abs(dg), Math.abs(db));

                let alpha = 255;
                if (dist <= keyThreshold) {
                    alpha = 0;
                } else if (dist <= keyThreshold + keySoftness) {
                    alpha = Math.round(255 * (dist - keyThreshold) / keySoftness);
                }

                if (alpha > 0) {
                    const spill = Math.min(r, b) - g;
                    if (spill > 0) {
                        const reduce = spill * despillStrength;
                        data[i] = Math.max(0, r - reduce);
                        data[i + 2] = Math.max(0, b - reduce);
                    }
                    data[i + 3] = alpha;
                    hasContent = true;
                    const px = (i / 4) % w;
                    const py = Math.floor((i / 4) / w);
                    if (px < minX) minX = px;
                    if (py < minY) minY = py;
                    if (px > maxX) maxX = px;
                    if (py > maxY) maxY = py;
                } else {
                    data[i + 3] = 0;
                }
            }

            if (hasContent) {
                contentBounds = { left: minX, top: minY, right: maxX, bottom: maxY };
            } else {
                contentBounds = null;
            }

            streamCtx.putImageData(frame, 0, 0);
            scheduleFrame();
        }

        function scheduleFrame() {
            if (!frameLoopActive) return;
            if (typeof remoteVideo.requestVideoFrameCallback === 'function') {
                remoteVideo.requestVideoFrameCallback(processFrame);
            } else {
                setTimeout(processFrame, 33);
            }
        }

        function startFrameLoop() {
            if (frameLoopActive) return;
            frameLoopActive = true;
            scheduleFrame();
        }

        function stopFrameLoop() {
            frameLoopActive = false;
        }


        if (channel) {
            channel.onmessage = (event) => {
                const msg = readChannelMessage(event) || {};
                if (msg.role === 'rtc') return;
                if (msg.type === 'offer') {
                    handleOffer(msg);
                } else if (msg.type === 'ice' && msg.sessionId === currentSessionId && msg.candidate) {
                    if (pc) {
                        pc.addIceCandidate(new RTCIceCandidate(msg.candidate)).catch(() => {});
                    }
                } else if (msg.type === 'stop' && msg.sessionId === currentSessionId) {
                    closePeer('stopped by sender');
                }
            };
        } else {
            setStatus('BroadcastChannel unavailable');
            requestBtn.disabled = true;
        }

        requestBtn.addEventListener('click', () => {
            if (!channel) return;
            setStatus('requesting stream');
            sendChannelMessage({ type: 'request-offer', role: 'rtc' });
        });

        disconnectBtn.addEventListener('click', () => {
            closePeer('disconnected');
        });

        watermarkToggle.addEventListener('change', () => {
            if (watermarkToggle.checked) {
                stageEl.classList.remove('full');
            } else {
                stageEl.classList.add('full');
            }
        });
        setOutlineVisible(false);

        streamOverlay.addEventListener('pointerdown', (event) => {
            if (event.target === resizeHandle) return;
            beginDrag(event);
            showOutlineTemporarily();
        });
        streamOverlay.addEventListener('pointermove', onDrag);
        streamOverlay.addEventListener('pointerup', endDrag);
        streamOverlay.addEventListener('pointercancel', endDrag);

        resizeHandle.addEventListener('pointerdown', (event) => {
            showOutlineTemporarily();
            beginResize(event);
        });
        resizeHandle.addEventListener('pointermove', onResize);
        resizeHandle.addEventListener('pointerup', endResize);
        resizeHandle.addEventListener('pointercancel', endResize);

        resizeHandle.addEventListener('click', (event) => {
            event.stopPropagation();
            resizeEnabled = !resizeEnabled;
            streamOverlay.classList.toggle('resize-active', resizeEnabled);
            showOutlineTemporarily();
        });

        stageEl.addEventListener('pointermove', showOutlineTemporarily);

        bgVideoInput.addEventListener('change', (event) => {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            backgroundVideo.src = url;
            backgroundVideo.play().catch(() => {});
            bgPlaceholder.style.display = 'none';
        });

        remoteVideo.addEventListener('loadedmetadata', () => {
            remoteVideo.play().catch(() => {});
        });

        window.addEventListener('beforeunload', () => {
            closePeer('closing');
        });
    </script>
</body>
</html>
